<?php
/**
 * ManagementApi
 * PHP version 8.1
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Voucherify API
 *
 * Voucherify promotion engine REST API. Please see https://docs.voucherify.io/docs for more details.
 *
 * The version of the OpenAPI document: v2018-08-01
 * Contact: support@voucherify.io
 * @generated Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 7.0.1
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * ManagementApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class ManagementApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'assignUser' => [
            'application/json',
        ],
        'createBrand' => [
            'application/json',
        ],
        'createCustomEventSchema' => [
            'application/json',
        ],
        'createMetadataSchema' => [
            'application/json',
        ],
        'createProject' => [
            'application/json',
        ],
        'createStackingRules' => [
            'application/json',
        ],
        'createWebhook' => [
            'application/json',
        ],
        'deleteBrand' => [
            'application/json',
        ],
        'deleteCustomEventSchema' => [
            'application/json',
        ],
        'deleteMetadataSchema' => [
            'application/json',
        ],
        'deleteProject' => [
            'application/json',
        ],
        'deleteStackingRules' => [
            'application/json',
        ],
        'deleteWebhook' => [
            'application/json',
        ],
        'getBrand' => [
            'application/json',
        ],
        'getCustomEventSchema' => [
            'application/json',
        ],
        'getMetadataSchema1' => [
            'application/json',
        ],
        'getProject' => [
            'application/json',
        ],
        'getStackingRules' => [
            'application/json',
        ],
        'getUser' => [
            'application/json',
        ],
        'getWebhook' => [
            'application/json',
        ],
        'inviteUser' => [
            'application/json',
        ],
        'listBrands' => [
            'application/json',
        ],
        'listCustomEventSchemas' => [
            'application/json',
        ],
        'listMetadataSchemas1' => [
            'application/json',
        ],
        'listProjects' => [
            'application/json',
        ],
        'listStackingRules' => [
            'application/json',
        ],
        'listUsers' => [
            'application/json',
        ],
        'listWebhooks' => [
            'application/json',
        ],
        'unassignUser' => [
            'application/json',
        ],
        'updateBrand' => [
            'application/json',
        ],
        'updateCustomEventSchema' => [
            'application/json',
        ],
        'updateMetadataSchema' => [
            'application/json',
        ],
        'updateProject' => [
            'application/json',
        ],
        'updateStackingRules' => [
            'application/json',
        ],
        'updateUser' => [
            'application/json',
        ],
        'updateWebhook' => [
            'application/json',
        ],
    ];

/**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation assignUser
     *
     * Assign User
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  \OpenAPI\Client\Model\ManagementProjectsUsersAssignRequestBody $managementProjectsUsersAssignRequestBody Defines the user details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['assignUser'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ManagementProjectsUsersAssignResponseBody
     */
    public function assignUser($projectId, $managementProjectsUsersAssignRequestBody = null, string $contentType = self::contentTypes['assignUser'][0])
    {
        list($response) = $this->assignUserWithHttpInfo($projectId, $managementProjectsUsersAssignRequestBody, $contentType);
        return $response;
    }

    /**
     * Operation assignUserWithHttpInfo
     *
     * Assign User
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  \OpenAPI\Client\Model\ManagementProjectsUsersAssignRequestBody $managementProjectsUsersAssignRequestBody Defines the user details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['assignUser'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ManagementProjectsUsersAssignResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function assignUserWithHttpInfo($projectId, $managementProjectsUsersAssignRequestBody = null, string $contentType = self::contentTypes['assignUser'][0])
    {
        $request = $this->assignUserRequest($projectId, $managementProjectsUsersAssignRequestBody, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ManagementProjectsUsersAssignResponseBody' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ManagementProjectsUsersAssignResponseBody' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ManagementProjectsUsersAssignResponseBody', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ManagementProjectsUsersAssignResponseBody';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ManagementProjectsUsersAssignResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation assignUserAsync
     *
     * Assign User
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  \OpenAPI\Client\Model\ManagementProjectsUsersAssignRequestBody $managementProjectsUsersAssignRequestBody Defines the user details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['assignUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function assignUserAsync($projectId, $managementProjectsUsersAssignRequestBody = null, string $contentType = self::contentTypes['assignUser'][0])
    {
        return $this->assignUserAsyncWithHttpInfo($projectId, $managementProjectsUsersAssignRequestBody, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation assignUserAsyncWithHttpInfo
     *
     * Assign User
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  \OpenAPI\Client\Model\ManagementProjectsUsersAssignRequestBody $managementProjectsUsersAssignRequestBody Defines the user details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['assignUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function assignUserAsyncWithHttpInfo($projectId, $managementProjectsUsersAssignRequestBody = null, string $contentType = self::contentTypes['assignUser'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ManagementProjectsUsersAssignResponseBody';
        $request = $this->assignUserRequest($projectId, $managementProjectsUsersAssignRequestBody, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'assignUser'
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  \OpenAPI\Client\Model\ManagementProjectsUsersAssignRequestBody $managementProjectsUsersAssignRequestBody Defines the user details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['assignUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function assignUserRequest($projectId, $managementProjectsUsersAssignRequestBody = null, string $contentType = self::contentTypes['assignUser'][0])
    {

        // verify the required parameter 'projectId' is set
        if ($projectId === null || (is_array($projectId) && count($projectId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projectId when calling assignUser'
            );
        }



        $resourcePath = '/management/v1/projects/{projectId}/users';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($projectId !== null) {
            $resourcePath = str_replace(
                '{' . 'projectId' . '}',
                ObjectSerializer::toPathValue($projectId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($managementProjectsUsersAssignRequestBody)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($managementProjectsUsersAssignRequestBody));
            } else {
                $httpBody = $managementProjectsUsersAssignRequestBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Management-Token');
        if ($apiKey !== null) {
            $headers['X-Management-Token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Management-Id');
        if ($apiKey !== null) {
            $headers['X-Management-Id'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createBrand
     *
     * Create Brand
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  \OpenAPI\Client\Model\ManagementProjectsBrandingCreateRequestBody $managementProjectsBrandingCreateRequestBody Defines a brand configuration. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createBrand'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ManagementProjectsBrandingCreateResponseBody
     */
    public function createBrand($projectId, $managementProjectsBrandingCreateRequestBody = null, string $contentType = self::contentTypes['createBrand'][0])
    {
        list($response) = $this->createBrandWithHttpInfo($projectId, $managementProjectsBrandingCreateRequestBody, $contentType);
        return $response;
    }

    /**
     * Operation createBrandWithHttpInfo
     *
     * Create Brand
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  \OpenAPI\Client\Model\ManagementProjectsBrandingCreateRequestBody $managementProjectsBrandingCreateRequestBody Defines a brand configuration. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createBrand'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ManagementProjectsBrandingCreateResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function createBrandWithHttpInfo($projectId, $managementProjectsBrandingCreateRequestBody = null, string $contentType = self::contentTypes['createBrand'][0])
    {
        $request = $this->createBrandRequest($projectId, $managementProjectsBrandingCreateRequestBody, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ManagementProjectsBrandingCreateResponseBody' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ManagementProjectsBrandingCreateResponseBody' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ManagementProjectsBrandingCreateResponseBody', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ManagementProjectsBrandingCreateResponseBody';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ManagementProjectsBrandingCreateResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createBrandAsync
     *
     * Create Brand
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  \OpenAPI\Client\Model\ManagementProjectsBrandingCreateRequestBody $managementProjectsBrandingCreateRequestBody Defines a brand configuration. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createBrand'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createBrandAsync($projectId, $managementProjectsBrandingCreateRequestBody = null, string $contentType = self::contentTypes['createBrand'][0])
    {
        return $this->createBrandAsyncWithHttpInfo($projectId, $managementProjectsBrandingCreateRequestBody, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createBrandAsyncWithHttpInfo
     *
     * Create Brand
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  \OpenAPI\Client\Model\ManagementProjectsBrandingCreateRequestBody $managementProjectsBrandingCreateRequestBody Defines a brand configuration. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createBrand'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createBrandAsyncWithHttpInfo($projectId, $managementProjectsBrandingCreateRequestBody = null, string $contentType = self::contentTypes['createBrand'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ManagementProjectsBrandingCreateResponseBody';
        $request = $this->createBrandRequest($projectId, $managementProjectsBrandingCreateRequestBody, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createBrand'
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  \OpenAPI\Client\Model\ManagementProjectsBrandingCreateRequestBody $managementProjectsBrandingCreateRequestBody Defines a brand configuration. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createBrand'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createBrandRequest($projectId, $managementProjectsBrandingCreateRequestBody = null, string $contentType = self::contentTypes['createBrand'][0])
    {

        // verify the required parameter 'projectId' is set
        if ($projectId === null || (is_array($projectId) && count($projectId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projectId when calling createBrand'
            );
        }



        $resourcePath = '/management/v1/projects/{projectId}/branding';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($projectId !== null) {
            $resourcePath = str_replace(
                '{' . 'projectId' . '}',
                ObjectSerializer::toPathValue($projectId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($managementProjectsBrandingCreateRequestBody)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($managementProjectsBrandingCreateRequestBody));
            } else {
                $httpBody = $managementProjectsBrandingCreateRequestBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Management-Token');
        if ($apiKey !== null) {
            $headers['X-Management-Token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Management-Id');
        if ($apiKey !== null) {
            $headers['X-Management-Id'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createCustomEventSchema
     *
     * Create Custom Event Schema
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  \OpenAPI\Client\Model\ManagementProjectsCustomEventSchemasCreateRequestBody $managementProjectsCustomEventSchemasCreateRequestBody Defines the custom event schema. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCustomEventSchema'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ManagementProjectsCustomEventSchemasCreateResponseBody
     */
    public function createCustomEventSchema($projectId, $managementProjectsCustomEventSchemasCreateRequestBody = null, string $contentType = self::contentTypes['createCustomEventSchema'][0])
    {
        list($response) = $this->createCustomEventSchemaWithHttpInfo($projectId, $managementProjectsCustomEventSchemasCreateRequestBody, $contentType);
        return $response;
    }

    /**
     * Operation createCustomEventSchemaWithHttpInfo
     *
     * Create Custom Event Schema
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  \OpenAPI\Client\Model\ManagementProjectsCustomEventSchemasCreateRequestBody $managementProjectsCustomEventSchemasCreateRequestBody Defines the custom event schema. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCustomEventSchema'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ManagementProjectsCustomEventSchemasCreateResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function createCustomEventSchemaWithHttpInfo($projectId, $managementProjectsCustomEventSchemasCreateRequestBody = null, string $contentType = self::contentTypes['createCustomEventSchema'][0])
    {
        $request = $this->createCustomEventSchemaRequest($projectId, $managementProjectsCustomEventSchemasCreateRequestBody, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ManagementProjectsCustomEventSchemasCreateResponseBody' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ManagementProjectsCustomEventSchemasCreateResponseBody' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ManagementProjectsCustomEventSchemasCreateResponseBody', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ManagementProjectsCustomEventSchemasCreateResponseBody';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ManagementProjectsCustomEventSchemasCreateResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createCustomEventSchemaAsync
     *
     * Create Custom Event Schema
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  \OpenAPI\Client\Model\ManagementProjectsCustomEventSchemasCreateRequestBody $managementProjectsCustomEventSchemasCreateRequestBody Defines the custom event schema. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCustomEventSchema'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createCustomEventSchemaAsync($projectId, $managementProjectsCustomEventSchemasCreateRequestBody = null, string $contentType = self::contentTypes['createCustomEventSchema'][0])
    {
        return $this->createCustomEventSchemaAsyncWithHttpInfo($projectId, $managementProjectsCustomEventSchemasCreateRequestBody, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createCustomEventSchemaAsyncWithHttpInfo
     *
     * Create Custom Event Schema
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  \OpenAPI\Client\Model\ManagementProjectsCustomEventSchemasCreateRequestBody $managementProjectsCustomEventSchemasCreateRequestBody Defines the custom event schema. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCustomEventSchema'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createCustomEventSchemaAsyncWithHttpInfo($projectId, $managementProjectsCustomEventSchemasCreateRequestBody = null, string $contentType = self::contentTypes['createCustomEventSchema'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ManagementProjectsCustomEventSchemasCreateResponseBody';
        $request = $this->createCustomEventSchemaRequest($projectId, $managementProjectsCustomEventSchemasCreateRequestBody, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createCustomEventSchema'
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  \OpenAPI\Client\Model\ManagementProjectsCustomEventSchemasCreateRequestBody $managementProjectsCustomEventSchemasCreateRequestBody Defines the custom event schema. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCustomEventSchema'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createCustomEventSchemaRequest($projectId, $managementProjectsCustomEventSchemasCreateRequestBody = null, string $contentType = self::contentTypes['createCustomEventSchema'][0])
    {

        // verify the required parameter 'projectId' is set
        if ($projectId === null || (is_array($projectId) && count($projectId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projectId when calling createCustomEventSchema'
            );
        }



        $resourcePath = '/management/v1/projects/{projectId}/custom-event-schemas';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($projectId !== null) {
            $resourcePath = str_replace(
                '{' . 'projectId' . '}',
                ObjectSerializer::toPathValue($projectId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($managementProjectsCustomEventSchemasCreateRequestBody)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($managementProjectsCustomEventSchemasCreateRequestBody));
            } else {
                $httpBody = $managementProjectsCustomEventSchemasCreateRequestBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Management-Token');
        if ($apiKey !== null) {
            $headers['X-Management-Token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Management-Id');
        if ($apiKey !== null) {
            $headers['X-Management-Id'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createMetadataSchema
     *
     * Create Metadata Schema
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  \OpenAPI\Client\Model\ManagementProjectsMetadataSchemasCreateRequestBody $managementProjectsMetadataSchemasCreateRequestBody Defines the metadata schema. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createMetadataSchema'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ManagementProjectsMetadataSchemasCreateResponseBody
     */
    public function createMetadataSchema($projectId, $managementProjectsMetadataSchemasCreateRequestBody = null, string $contentType = self::contentTypes['createMetadataSchema'][0])
    {
        list($response) = $this->createMetadataSchemaWithHttpInfo($projectId, $managementProjectsMetadataSchemasCreateRequestBody, $contentType);
        return $response;
    }

    /**
     * Operation createMetadataSchemaWithHttpInfo
     *
     * Create Metadata Schema
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  \OpenAPI\Client\Model\ManagementProjectsMetadataSchemasCreateRequestBody $managementProjectsMetadataSchemasCreateRequestBody Defines the metadata schema. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createMetadataSchema'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ManagementProjectsMetadataSchemasCreateResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function createMetadataSchemaWithHttpInfo($projectId, $managementProjectsMetadataSchemasCreateRequestBody = null, string $contentType = self::contentTypes['createMetadataSchema'][0])
    {
        $request = $this->createMetadataSchemaRequest($projectId, $managementProjectsMetadataSchemasCreateRequestBody, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ManagementProjectsMetadataSchemasCreateResponseBody' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ManagementProjectsMetadataSchemasCreateResponseBody' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ManagementProjectsMetadataSchemasCreateResponseBody', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ManagementProjectsMetadataSchemasCreateResponseBody';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ManagementProjectsMetadataSchemasCreateResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createMetadataSchemaAsync
     *
     * Create Metadata Schema
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  \OpenAPI\Client\Model\ManagementProjectsMetadataSchemasCreateRequestBody $managementProjectsMetadataSchemasCreateRequestBody Defines the metadata schema. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createMetadataSchema'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createMetadataSchemaAsync($projectId, $managementProjectsMetadataSchemasCreateRequestBody = null, string $contentType = self::contentTypes['createMetadataSchema'][0])
    {
        return $this->createMetadataSchemaAsyncWithHttpInfo($projectId, $managementProjectsMetadataSchemasCreateRequestBody, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createMetadataSchemaAsyncWithHttpInfo
     *
     * Create Metadata Schema
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  \OpenAPI\Client\Model\ManagementProjectsMetadataSchemasCreateRequestBody $managementProjectsMetadataSchemasCreateRequestBody Defines the metadata schema. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createMetadataSchema'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createMetadataSchemaAsyncWithHttpInfo($projectId, $managementProjectsMetadataSchemasCreateRequestBody = null, string $contentType = self::contentTypes['createMetadataSchema'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ManagementProjectsMetadataSchemasCreateResponseBody';
        $request = $this->createMetadataSchemaRequest($projectId, $managementProjectsMetadataSchemasCreateRequestBody, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createMetadataSchema'
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  \OpenAPI\Client\Model\ManagementProjectsMetadataSchemasCreateRequestBody $managementProjectsMetadataSchemasCreateRequestBody Defines the metadata schema. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createMetadataSchema'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createMetadataSchemaRequest($projectId, $managementProjectsMetadataSchemasCreateRequestBody = null, string $contentType = self::contentTypes['createMetadataSchema'][0])
    {

        // verify the required parameter 'projectId' is set
        if ($projectId === null || (is_array($projectId) && count($projectId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projectId when calling createMetadataSchema'
            );
        }



        $resourcePath = '/management/v1/projects/{projectId}/metadata-schemas';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($projectId !== null) {
            $resourcePath = str_replace(
                '{' . 'projectId' . '}',
                ObjectSerializer::toPathValue($projectId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($managementProjectsMetadataSchemasCreateRequestBody)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($managementProjectsMetadataSchemasCreateRequestBody));
            } else {
                $httpBody = $managementProjectsMetadataSchemasCreateRequestBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Management-Token');
        if ($apiKey !== null) {
            $headers['X-Management-Token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Management-Id');
        if ($apiKey !== null) {
            $headers['X-Management-Id'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createProject
     *
     * Create Project
     *
     * @param  \OpenAPI\Client\Model\ManagementProjectsCreateRequestBody $managementProjectsCreateRequestBody Define project details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createProject'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ManagementProjectsCreateResponseBody
     */
    public function createProject($managementProjectsCreateRequestBody = null, string $contentType = self::contentTypes['createProject'][0])
    {
        list($response) = $this->createProjectWithHttpInfo($managementProjectsCreateRequestBody, $contentType);
        return $response;
    }

    /**
     * Operation createProjectWithHttpInfo
     *
     * Create Project
     *
     * @param  \OpenAPI\Client\Model\ManagementProjectsCreateRequestBody $managementProjectsCreateRequestBody Define project details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createProject'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ManagementProjectsCreateResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function createProjectWithHttpInfo($managementProjectsCreateRequestBody = null, string $contentType = self::contentTypes['createProject'][0])
    {
        $request = $this->createProjectRequest($managementProjectsCreateRequestBody, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ManagementProjectsCreateResponseBody' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ManagementProjectsCreateResponseBody' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ManagementProjectsCreateResponseBody', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ManagementProjectsCreateResponseBody';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ManagementProjectsCreateResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createProjectAsync
     *
     * Create Project
     *
     * @param  \OpenAPI\Client\Model\ManagementProjectsCreateRequestBody $managementProjectsCreateRequestBody Define project details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createProject'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createProjectAsync($managementProjectsCreateRequestBody = null, string $contentType = self::contentTypes['createProject'][0])
    {
        return $this->createProjectAsyncWithHttpInfo($managementProjectsCreateRequestBody, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createProjectAsyncWithHttpInfo
     *
     * Create Project
     *
     * @param  \OpenAPI\Client\Model\ManagementProjectsCreateRequestBody $managementProjectsCreateRequestBody Define project details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createProject'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createProjectAsyncWithHttpInfo($managementProjectsCreateRequestBody = null, string $contentType = self::contentTypes['createProject'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ManagementProjectsCreateResponseBody';
        $request = $this->createProjectRequest($managementProjectsCreateRequestBody, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createProject'
     *
     * @param  \OpenAPI\Client\Model\ManagementProjectsCreateRequestBody $managementProjectsCreateRequestBody Define project details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createProject'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createProjectRequest($managementProjectsCreateRequestBody = null, string $contentType = self::contentTypes['createProject'][0])
    {



        $resourcePath = '/management/v1/projects';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($managementProjectsCreateRequestBody)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($managementProjectsCreateRequestBody));
            } else {
                $httpBody = $managementProjectsCreateRequestBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Management-Token');
        if ($apiKey !== null) {
            $headers['X-Management-Token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Management-Id');
        if ($apiKey !== null) {
            $headers['X-Management-Id'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createStackingRules
     *
     * Create Stacking Rules
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  \OpenAPI\Client\Model\ManagementProjectsStackingRulesCreateRequestBody $managementProjectsStackingRulesCreateRequestBody Defines the stacking rule parameters. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createStackingRules'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ManagementProjectsStackingRulesCreateResponseBody
     */
    public function createStackingRules($projectId, $managementProjectsStackingRulesCreateRequestBody = null, string $contentType = self::contentTypes['createStackingRules'][0])
    {
        list($response) = $this->createStackingRulesWithHttpInfo($projectId, $managementProjectsStackingRulesCreateRequestBody, $contentType);
        return $response;
    }

    /**
     * Operation createStackingRulesWithHttpInfo
     *
     * Create Stacking Rules
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  \OpenAPI\Client\Model\ManagementProjectsStackingRulesCreateRequestBody $managementProjectsStackingRulesCreateRequestBody Defines the stacking rule parameters. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createStackingRules'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ManagementProjectsStackingRulesCreateResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function createStackingRulesWithHttpInfo($projectId, $managementProjectsStackingRulesCreateRequestBody = null, string $contentType = self::contentTypes['createStackingRules'][0])
    {
        $request = $this->createStackingRulesRequest($projectId, $managementProjectsStackingRulesCreateRequestBody, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ManagementProjectsStackingRulesCreateResponseBody' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ManagementProjectsStackingRulesCreateResponseBody' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ManagementProjectsStackingRulesCreateResponseBody', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ManagementProjectsStackingRulesCreateResponseBody';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ManagementProjectsStackingRulesCreateResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createStackingRulesAsync
     *
     * Create Stacking Rules
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  \OpenAPI\Client\Model\ManagementProjectsStackingRulesCreateRequestBody $managementProjectsStackingRulesCreateRequestBody Defines the stacking rule parameters. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createStackingRules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createStackingRulesAsync($projectId, $managementProjectsStackingRulesCreateRequestBody = null, string $contentType = self::contentTypes['createStackingRules'][0])
    {
        return $this->createStackingRulesAsyncWithHttpInfo($projectId, $managementProjectsStackingRulesCreateRequestBody, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createStackingRulesAsyncWithHttpInfo
     *
     * Create Stacking Rules
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  \OpenAPI\Client\Model\ManagementProjectsStackingRulesCreateRequestBody $managementProjectsStackingRulesCreateRequestBody Defines the stacking rule parameters. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createStackingRules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createStackingRulesAsyncWithHttpInfo($projectId, $managementProjectsStackingRulesCreateRequestBody = null, string $contentType = self::contentTypes['createStackingRules'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ManagementProjectsStackingRulesCreateResponseBody';
        $request = $this->createStackingRulesRequest($projectId, $managementProjectsStackingRulesCreateRequestBody, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createStackingRules'
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  \OpenAPI\Client\Model\ManagementProjectsStackingRulesCreateRequestBody $managementProjectsStackingRulesCreateRequestBody Defines the stacking rule parameters. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createStackingRules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createStackingRulesRequest($projectId, $managementProjectsStackingRulesCreateRequestBody = null, string $contentType = self::contentTypes['createStackingRules'][0])
    {

        // verify the required parameter 'projectId' is set
        if ($projectId === null || (is_array($projectId) && count($projectId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projectId when calling createStackingRules'
            );
        }



        $resourcePath = '/management/v1/projects/{projectId}/stacking-rules';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($projectId !== null) {
            $resourcePath = str_replace(
                '{' . 'projectId' . '}',
                ObjectSerializer::toPathValue($projectId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($managementProjectsStackingRulesCreateRequestBody)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($managementProjectsStackingRulesCreateRequestBody));
            } else {
                $httpBody = $managementProjectsStackingRulesCreateRequestBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Management-Token');
        if ($apiKey !== null) {
            $headers['X-Management-Token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Management-Id');
        if ($apiKey !== null) {
            $headers['X-Management-Id'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createWebhook
     *
     * Create Webhook
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  \OpenAPI\Client\Model\ManagementProjectsWebhooksCreateRequestBody $managementProjectsWebhooksCreateRequestBody Defines a webhook configuration. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createWebhook'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ManagementProjectsWebhooksCreateResponseBody
     */
    public function createWebhook($projectId, $managementProjectsWebhooksCreateRequestBody = null, string $contentType = self::contentTypes['createWebhook'][0])
    {
        list($response) = $this->createWebhookWithHttpInfo($projectId, $managementProjectsWebhooksCreateRequestBody, $contentType);
        return $response;
    }

    /**
     * Operation createWebhookWithHttpInfo
     *
     * Create Webhook
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  \OpenAPI\Client\Model\ManagementProjectsWebhooksCreateRequestBody $managementProjectsWebhooksCreateRequestBody Defines a webhook configuration. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createWebhook'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ManagementProjectsWebhooksCreateResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function createWebhookWithHttpInfo($projectId, $managementProjectsWebhooksCreateRequestBody = null, string $contentType = self::contentTypes['createWebhook'][0])
    {
        $request = $this->createWebhookRequest($projectId, $managementProjectsWebhooksCreateRequestBody, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ManagementProjectsWebhooksCreateResponseBody' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ManagementProjectsWebhooksCreateResponseBody' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ManagementProjectsWebhooksCreateResponseBody', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ManagementProjectsWebhooksCreateResponseBody';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ManagementProjectsWebhooksCreateResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createWebhookAsync
     *
     * Create Webhook
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  \OpenAPI\Client\Model\ManagementProjectsWebhooksCreateRequestBody $managementProjectsWebhooksCreateRequestBody Defines a webhook configuration. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createWebhook'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createWebhookAsync($projectId, $managementProjectsWebhooksCreateRequestBody = null, string $contentType = self::contentTypes['createWebhook'][0])
    {
        return $this->createWebhookAsyncWithHttpInfo($projectId, $managementProjectsWebhooksCreateRequestBody, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createWebhookAsyncWithHttpInfo
     *
     * Create Webhook
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  \OpenAPI\Client\Model\ManagementProjectsWebhooksCreateRequestBody $managementProjectsWebhooksCreateRequestBody Defines a webhook configuration. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createWebhook'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createWebhookAsyncWithHttpInfo($projectId, $managementProjectsWebhooksCreateRequestBody = null, string $contentType = self::contentTypes['createWebhook'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ManagementProjectsWebhooksCreateResponseBody';
        $request = $this->createWebhookRequest($projectId, $managementProjectsWebhooksCreateRequestBody, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createWebhook'
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  \OpenAPI\Client\Model\ManagementProjectsWebhooksCreateRequestBody $managementProjectsWebhooksCreateRequestBody Defines a webhook configuration. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createWebhook'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createWebhookRequest($projectId, $managementProjectsWebhooksCreateRequestBody = null, string $contentType = self::contentTypes['createWebhook'][0])
    {

        // verify the required parameter 'projectId' is set
        if ($projectId === null || (is_array($projectId) && count($projectId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projectId when calling createWebhook'
            );
        }



        $resourcePath = '/management/v1/projects/{projectId}/webhooks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($projectId !== null) {
            $resourcePath = str_replace(
                '{' . 'projectId' . '}',
                ObjectSerializer::toPathValue($projectId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($managementProjectsWebhooksCreateRequestBody)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($managementProjectsWebhooksCreateRequestBody));
            } else {
                $httpBody = $managementProjectsWebhooksCreateRequestBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Management-Token');
        if ($apiKey !== null) {
            $headers['X-Management-Token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Management-Id');
        if ($apiKey !== null) {
            $headers['X-Management-Id'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteBrand
     *
     * Delete Brand
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $brandingId Provide the unique identifier of the brand configuration. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteBrand'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteBrand($projectId, $brandingId, string $contentType = self::contentTypes['deleteBrand'][0])
    {
        $this->deleteBrandWithHttpInfo($projectId, $brandingId, $contentType);
    }

    /**
     * Operation deleteBrandWithHttpInfo
     *
     * Delete Brand
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $brandingId Provide the unique identifier of the brand configuration. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteBrand'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteBrandWithHttpInfo($projectId, $brandingId, string $contentType = self::contentTypes['deleteBrand'][0])
    {
        $request = $this->deleteBrandRequest($projectId, $brandingId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteBrandAsync
     *
     * Delete Brand
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $brandingId Provide the unique identifier of the brand configuration. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteBrand'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteBrandAsync($projectId, $brandingId, string $contentType = self::contentTypes['deleteBrand'][0])
    {
        return $this->deleteBrandAsyncWithHttpInfo($projectId, $brandingId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteBrandAsyncWithHttpInfo
     *
     * Delete Brand
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $brandingId Provide the unique identifier of the brand configuration. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteBrand'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteBrandAsyncWithHttpInfo($projectId, $brandingId, string $contentType = self::contentTypes['deleteBrand'][0])
    {
        $returnType = '';
        $request = $this->deleteBrandRequest($projectId, $brandingId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteBrand'
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $brandingId Provide the unique identifier of the brand configuration. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteBrand'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteBrandRequest($projectId, $brandingId, string $contentType = self::contentTypes['deleteBrand'][0])
    {

        // verify the required parameter 'projectId' is set
        if ($projectId === null || (is_array($projectId) && count($projectId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projectId when calling deleteBrand'
            );
        }

        // verify the required parameter 'brandingId' is set
        if ($brandingId === null || (is_array($brandingId) && count($brandingId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $brandingId when calling deleteBrand'
            );
        }


        $resourcePath = '/management/v1/projects/{projectId}/branding/{brandingId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($projectId !== null) {
            $resourcePath = str_replace(
                '{' . 'projectId' . '}',
                ObjectSerializer::toPathValue($projectId),
                $resourcePath
            );
        }
        // path params
        if ($brandingId !== null) {
            $resourcePath = str_replace(
                '{' . 'brandingId' . '}',
                ObjectSerializer::toPathValue($brandingId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Management-Token');
        if ($apiKey !== null) {
            $headers['X-Management-Token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Management-Id');
        if ($apiKey !== null) {
            $headers['X-Management-Id'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteCustomEventSchema
     *
     * Delete Custom Event Schema
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $customEventSchemaId Provide the unique identifier of the custom event schema. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteCustomEventSchema'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteCustomEventSchema($projectId, $customEventSchemaId, string $contentType = self::contentTypes['deleteCustomEventSchema'][0])
    {
        $this->deleteCustomEventSchemaWithHttpInfo($projectId, $customEventSchemaId, $contentType);
    }

    /**
     * Operation deleteCustomEventSchemaWithHttpInfo
     *
     * Delete Custom Event Schema
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $customEventSchemaId Provide the unique identifier of the custom event schema. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteCustomEventSchema'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCustomEventSchemaWithHttpInfo($projectId, $customEventSchemaId, string $contentType = self::contentTypes['deleteCustomEventSchema'][0])
    {
        $request = $this->deleteCustomEventSchemaRequest($projectId, $customEventSchemaId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteCustomEventSchemaAsync
     *
     * Delete Custom Event Schema
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $customEventSchemaId Provide the unique identifier of the custom event schema. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteCustomEventSchema'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCustomEventSchemaAsync($projectId, $customEventSchemaId, string $contentType = self::contentTypes['deleteCustomEventSchema'][0])
    {
        return $this->deleteCustomEventSchemaAsyncWithHttpInfo($projectId, $customEventSchemaId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteCustomEventSchemaAsyncWithHttpInfo
     *
     * Delete Custom Event Schema
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $customEventSchemaId Provide the unique identifier of the custom event schema. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteCustomEventSchema'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCustomEventSchemaAsyncWithHttpInfo($projectId, $customEventSchemaId, string $contentType = self::contentTypes['deleteCustomEventSchema'][0])
    {
        $returnType = '';
        $request = $this->deleteCustomEventSchemaRequest($projectId, $customEventSchemaId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteCustomEventSchema'
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $customEventSchemaId Provide the unique identifier of the custom event schema. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteCustomEventSchema'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteCustomEventSchemaRequest($projectId, $customEventSchemaId, string $contentType = self::contentTypes['deleteCustomEventSchema'][0])
    {

        // verify the required parameter 'projectId' is set
        if ($projectId === null || (is_array($projectId) && count($projectId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projectId when calling deleteCustomEventSchema'
            );
        }

        // verify the required parameter 'customEventSchemaId' is set
        if ($customEventSchemaId === null || (is_array($customEventSchemaId) && count($customEventSchemaId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $customEventSchemaId when calling deleteCustomEventSchema'
            );
        }


        $resourcePath = '/management/v1/projects/{projectId}/custom-event-schemas/{customEventSchemaId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($projectId !== null) {
            $resourcePath = str_replace(
                '{' . 'projectId' . '}',
                ObjectSerializer::toPathValue($projectId),
                $resourcePath
            );
        }
        // path params
        if ($customEventSchemaId !== null) {
            $resourcePath = str_replace(
                '{' . 'customEventSchemaId' . '}',
                ObjectSerializer::toPathValue($customEventSchemaId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Management-Token');
        if ($apiKey !== null) {
            $headers['X-Management-Token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Management-Id');
        if ($apiKey !== null) {
            $headers['X-Management-Id'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteMetadataSchema
     *
     * Delete Metadata Schema
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $metadataSchemaId Provide the unique identifier of the metadata schema. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteMetadataSchema'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteMetadataSchema($projectId, $metadataSchemaId, string $contentType = self::contentTypes['deleteMetadataSchema'][0])
    {
        $this->deleteMetadataSchemaWithHttpInfo($projectId, $metadataSchemaId, $contentType);
    }

    /**
     * Operation deleteMetadataSchemaWithHttpInfo
     *
     * Delete Metadata Schema
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $metadataSchemaId Provide the unique identifier of the metadata schema. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteMetadataSchema'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteMetadataSchemaWithHttpInfo($projectId, $metadataSchemaId, string $contentType = self::contentTypes['deleteMetadataSchema'][0])
    {
        $request = $this->deleteMetadataSchemaRequest($projectId, $metadataSchemaId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteMetadataSchemaAsync
     *
     * Delete Metadata Schema
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $metadataSchemaId Provide the unique identifier of the metadata schema. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteMetadataSchema'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteMetadataSchemaAsync($projectId, $metadataSchemaId, string $contentType = self::contentTypes['deleteMetadataSchema'][0])
    {
        return $this->deleteMetadataSchemaAsyncWithHttpInfo($projectId, $metadataSchemaId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteMetadataSchemaAsyncWithHttpInfo
     *
     * Delete Metadata Schema
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $metadataSchemaId Provide the unique identifier of the metadata schema. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteMetadataSchema'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteMetadataSchemaAsyncWithHttpInfo($projectId, $metadataSchemaId, string $contentType = self::contentTypes['deleteMetadataSchema'][0])
    {
        $returnType = '';
        $request = $this->deleteMetadataSchemaRequest($projectId, $metadataSchemaId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteMetadataSchema'
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $metadataSchemaId Provide the unique identifier of the metadata schema. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteMetadataSchema'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteMetadataSchemaRequest($projectId, $metadataSchemaId, string $contentType = self::contentTypes['deleteMetadataSchema'][0])
    {

        // verify the required parameter 'projectId' is set
        if ($projectId === null || (is_array($projectId) && count($projectId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projectId when calling deleteMetadataSchema'
            );
        }

        // verify the required parameter 'metadataSchemaId' is set
        if ($metadataSchemaId === null || (is_array($metadataSchemaId) && count($metadataSchemaId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $metadataSchemaId when calling deleteMetadataSchema'
            );
        }


        $resourcePath = '/management/v1/projects/{projectId}/metadata-schemas/{metadataSchemaId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($projectId !== null) {
            $resourcePath = str_replace(
                '{' . 'projectId' . '}',
                ObjectSerializer::toPathValue($projectId),
                $resourcePath
            );
        }
        // path params
        if ($metadataSchemaId !== null) {
            $resourcePath = str_replace(
                '{' . 'metadataSchemaId' . '}',
                ObjectSerializer::toPathValue($metadataSchemaId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Management-Token');
        if ($apiKey !== null) {
            $headers['X-Management-Token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Management-Id');
        if ($apiKey !== null) {
            $headers['X-Management-Id'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteProject
     *
     * Delete Project
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteProject'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteProject($projectId, string $contentType = self::contentTypes['deleteProject'][0])
    {
        $this->deleteProjectWithHttpInfo($projectId, $contentType);
    }

    /**
     * Operation deleteProjectWithHttpInfo
     *
     * Delete Project
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteProject'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteProjectWithHttpInfo($projectId, string $contentType = self::contentTypes['deleteProject'][0])
    {
        $request = $this->deleteProjectRequest($projectId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteProjectAsync
     *
     * Delete Project
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteProject'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteProjectAsync($projectId, string $contentType = self::contentTypes['deleteProject'][0])
    {
        return $this->deleteProjectAsyncWithHttpInfo($projectId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteProjectAsyncWithHttpInfo
     *
     * Delete Project
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteProject'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteProjectAsyncWithHttpInfo($projectId, string $contentType = self::contentTypes['deleteProject'][0])
    {
        $returnType = '';
        $request = $this->deleteProjectRequest($projectId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteProject'
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteProject'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteProjectRequest($projectId, string $contentType = self::contentTypes['deleteProject'][0])
    {

        // verify the required parameter 'projectId' is set
        if ($projectId === null || (is_array($projectId) && count($projectId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projectId when calling deleteProject'
            );
        }


        $resourcePath = '/management/v1/projects/{projectId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($projectId !== null) {
            $resourcePath = str_replace(
                '{' . 'projectId' . '}',
                ObjectSerializer::toPathValue($projectId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Management-Token');
        if ($apiKey !== null) {
            $headers['X-Management-Token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Management-Id');
        if ($apiKey !== null) {
            $headers['X-Management-Id'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteStackingRules
     *
     * Delete Stacking Rules
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $stackingRulesId Provide the unique identifier of the stacking rules. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteStackingRules'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteStackingRules($projectId, $stackingRulesId, string $contentType = self::contentTypes['deleteStackingRules'][0])
    {
        $this->deleteStackingRulesWithHttpInfo($projectId, $stackingRulesId, $contentType);
    }

    /**
     * Operation deleteStackingRulesWithHttpInfo
     *
     * Delete Stacking Rules
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $stackingRulesId Provide the unique identifier of the stacking rules. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteStackingRules'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteStackingRulesWithHttpInfo($projectId, $stackingRulesId, string $contentType = self::contentTypes['deleteStackingRules'][0])
    {
        $request = $this->deleteStackingRulesRequest($projectId, $stackingRulesId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteStackingRulesAsync
     *
     * Delete Stacking Rules
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $stackingRulesId Provide the unique identifier of the stacking rules. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteStackingRules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteStackingRulesAsync($projectId, $stackingRulesId, string $contentType = self::contentTypes['deleteStackingRules'][0])
    {
        return $this->deleteStackingRulesAsyncWithHttpInfo($projectId, $stackingRulesId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteStackingRulesAsyncWithHttpInfo
     *
     * Delete Stacking Rules
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $stackingRulesId Provide the unique identifier of the stacking rules. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteStackingRules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteStackingRulesAsyncWithHttpInfo($projectId, $stackingRulesId, string $contentType = self::contentTypes['deleteStackingRules'][0])
    {
        $returnType = '';
        $request = $this->deleteStackingRulesRequest($projectId, $stackingRulesId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteStackingRules'
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $stackingRulesId Provide the unique identifier of the stacking rules. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteStackingRules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteStackingRulesRequest($projectId, $stackingRulesId, string $contentType = self::contentTypes['deleteStackingRules'][0])
    {

        // verify the required parameter 'projectId' is set
        if ($projectId === null || (is_array($projectId) && count($projectId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projectId when calling deleteStackingRules'
            );
        }

        // verify the required parameter 'stackingRulesId' is set
        if ($stackingRulesId === null || (is_array($stackingRulesId) && count($stackingRulesId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $stackingRulesId when calling deleteStackingRules'
            );
        }


        $resourcePath = '/management/v1/projects/{projectId}/stacking-rules/{stackingRulesId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($projectId !== null) {
            $resourcePath = str_replace(
                '{' . 'projectId' . '}',
                ObjectSerializer::toPathValue($projectId),
                $resourcePath
            );
        }
        // path params
        if ($stackingRulesId !== null) {
            $resourcePath = str_replace(
                '{' . 'stackingRulesId' . '}',
                ObjectSerializer::toPathValue($stackingRulesId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Management-Token');
        if ($apiKey !== null) {
            $headers['X-Management-Token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Management-Id');
        if ($apiKey !== null) {
            $headers['X-Management-Id'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteWebhook
     *
     * Delete Webhook
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $webhookId Provide the unique identifier of the webhook configuration. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteWebhook'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteWebhook($projectId, $webhookId, string $contentType = self::contentTypes['deleteWebhook'][0])
    {
        $this->deleteWebhookWithHttpInfo($projectId, $webhookId, $contentType);
    }

    /**
     * Operation deleteWebhookWithHttpInfo
     *
     * Delete Webhook
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $webhookId Provide the unique identifier of the webhook configuration. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteWebhook'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteWebhookWithHttpInfo($projectId, $webhookId, string $contentType = self::contentTypes['deleteWebhook'][0])
    {
        $request = $this->deleteWebhookRequest($projectId, $webhookId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteWebhookAsync
     *
     * Delete Webhook
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $webhookId Provide the unique identifier of the webhook configuration. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteWebhook'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteWebhookAsync($projectId, $webhookId, string $contentType = self::contentTypes['deleteWebhook'][0])
    {
        return $this->deleteWebhookAsyncWithHttpInfo($projectId, $webhookId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteWebhookAsyncWithHttpInfo
     *
     * Delete Webhook
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $webhookId Provide the unique identifier of the webhook configuration. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteWebhook'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteWebhookAsyncWithHttpInfo($projectId, $webhookId, string $contentType = self::contentTypes['deleteWebhook'][0])
    {
        $returnType = '';
        $request = $this->deleteWebhookRequest($projectId, $webhookId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteWebhook'
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $webhookId Provide the unique identifier of the webhook configuration. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteWebhook'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteWebhookRequest($projectId, $webhookId, string $contentType = self::contentTypes['deleteWebhook'][0])
    {

        // verify the required parameter 'projectId' is set
        if ($projectId === null || (is_array($projectId) && count($projectId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projectId when calling deleteWebhook'
            );
        }

        // verify the required parameter 'webhookId' is set
        if ($webhookId === null || (is_array($webhookId) && count($webhookId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webhookId when calling deleteWebhook'
            );
        }


        $resourcePath = '/management/v1/projects/{projectId}/webhooks/{webhookId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($projectId !== null) {
            $resourcePath = str_replace(
                '{' . 'projectId' . '}',
                ObjectSerializer::toPathValue($projectId),
                $resourcePath
            );
        }
        // path params
        if ($webhookId !== null) {
            $resourcePath = str_replace(
                '{' . 'webhookId' . '}',
                ObjectSerializer::toPathValue($webhookId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Management-Token');
        if ($apiKey !== null) {
            $headers['X-Management-Token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Management-Id');
        if ($apiKey !== null) {
            $headers['X-Management-Id'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBrand
     *
     * Get Brand
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $brandingId Provide the unique identifier of the brand configuration. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBrand'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ManagementProjectsBrandingGetResponseBody
     */
    public function getBrand($projectId, $brandingId, string $contentType = self::contentTypes['getBrand'][0])
    {
        list($response) = $this->getBrandWithHttpInfo($projectId, $brandingId, $contentType);
        return $response;
    }

    /**
     * Operation getBrandWithHttpInfo
     *
     * Get Brand
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $brandingId Provide the unique identifier of the brand configuration. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBrand'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ManagementProjectsBrandingGetResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBrandWithHttpInfo($projectId, $brandingId, string $contentType = self::contentTypes['getBrand'][0])
    {
        $request = $this->getBrandRequest($projectId, $brandingId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ManagementProjectsBrandingGetResponseBody' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ManagementProjectsBrandingGetResponseBody' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ManagementProjectsBrandingGetResponseBody', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ManagementProjectsBrandingGetResponseBody';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ManagementProjectsBrandingGetResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBrandAsync
     *
     * Get Brand
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $brandingId Provide the unique identifier of the brand configuration. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBrand'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBrandAsync($projectId, $brandingId, string $contentType = self::contentTypes['getBrand'][0])
    {
        return $this->getBrandAsyncWithHttpInfo($projectId, $brandingId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBrandAsyncWithHttpInfo
     *
     * Get Brand
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $brandingId Provide the unique identifier of the brand configuration. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBrand'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBrandAsyncWithHttpInfo($projectId, $brandingId, string $contentType = self::contentTypes['getBrand'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ManagementProjectsBrandingGetResponseBody';
        $request = $this->getBrandRequest($projectId, $brandingId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBrand'
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $brandingId Provide the unique identifier of the brand configuration. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBrand'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getBrandRequest($projectId, $brandingId, string $contentType = self::contentTypes['getBrand'][0])
    {

        // verify the required parameter 'projectId' is set
        if ($projectId === null || (is_array($projectId) && count($projectId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projectId when calling getBrand'
            );
        }

        // verify the required parameter 'brandingId' is set
        if ($brandingId === null || (is_array($brandingId) && count($brandingId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $brandingId when calling getBrand'
            );
        }


        $resourcePath = '/management/v1/projects/{projectId}/branding/{brandingId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($projectId !== null) {
            $resourcePath = str_replace(
                '{' . 'projectId' . '}',
                ObjectSerializer::toPathValue($projectId),
                $resourcePath
            );
        }
        // path params
        if ($brandingId !== null) {
            $resourcePath = str_replace(
                '{' . 'brandingId' . '}',
                ObjectSerializer::toPathValue($brandingId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Management-Token');
        if ($apiKey !== null) {
            $headers['X-Management-Token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Management-Id');
        if ($apiKey !== null) {
            $headers['X-Management-Id'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCustomEventSchema
     *
     * Get Custom Event Schema
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $customEventSchemaId Provide the unique identifier of the custom event schema. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCustomEventSchema'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ManagementProjectsCustomEventSchemasGetResponseBody
     */
    public function getCustomEventSchema($projectId, $customEventSchemaId, string $contentType = self::contentTypes['getCustomEventSchema'][0])
    {
        list($response) = $this->getCustomEventSchemaWithHttpInfo($projectId, $customEventSchemaId, $contentType);
        return $response;
    }

    /**
     * Operation getCustomEventSchemaWithHttpInfo
     *
     * Get Custom Event Schema
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $customEventSchemaId Provide the unique identifier of the custom event schema. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCustomEventSchema'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ManagementProjectsCustomEventSchemasGetResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCustomEventSchemaWithHttpInfo($projectId, $customEventSchemaId, string $contentType = self::contentTypes['getCustomEventSchema'][0])
    {
        $request = $this->getCustomEventSchemaRequest($projectId, $customEventSchemaId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ManagementProjectsCustomEventSchemasGetResponseBody' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ManagementProjectsCustomEventSchemasGetResponseBody' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ManagementProjectsCustomEventSchemasGetResponseBody', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ManagementProjectsCustomEventSchemasGetResponseBody';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ManagementProjectsCustomEventSchemasGetResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCustomEventSchemaAsync
     *
     * Get Custom Event Schema
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $customEventSchemaId Provide the unique identifier of the custom event schema. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCustomEventSchema'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCustomEventSchemaAsync($projectId, $customEventSchemaId, string $contentType = self::contentTypes['getCustomEventSchema'][0])
    {
        return $this->getCustomEventSchemaAsyncWithHttpInfo($projectId, $customEventSchemaId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCustomEventSchemaAsyncWithHttpInfo
     *
     * Get Custom Event Schema
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $customEventSchemaId Provide the unique identifier of the custom event schema. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCustomEventSchema'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCustomEventSchemaAsyncWithHttpInfo($projectId, $customEventSchemaId, string $contentType = self::contentTypes['getCustomEventSchema'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ManagementProjectsCustomEventSchemasGetResponseBody';
        $request = $this->getCustomEventSchemaRequest($projectId, $customEventSchemaId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCustomEventSchema'
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $customEventSchemaId Provide the unique identifier of the custom event schema. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCustomEventSchema'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getCustomEventSchemaRequest($projectId, $customEventSchemaId, string $contentType = self::contentTypes['getCustomEventSchema'][0])
    {

        // verify the required parameter 'projectId' is set
        if ($projectId === null || (is_array($projectId) && count($projectId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projectId when calling getCustomEventSchema'
            );
        }

        // verify the required parameter 'customEventSchemaId' is set
        if ($customEventSchemaId === null || (is_array($customEventSchemaId) && count($customEventSchemaId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $customEventSchemaId when calling getCustomEventSchema'
            );
        }


        $resourcePath = '/management/v1/projects/{projectId}/custom-event-schemas/{customEventSchemaId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($projectId !== null) {
            $resourcePath = str_replace(
                '{' . 'projectId' . '}',
                ObjectSerializer::toPathValue($projectId),
                $resourcePath
            );
        }
        // path params
        if ($customEventSchemaId !== null) {
            $resourcePath = str_replace(
                '{' . 'customEventSchemaId' . '}',
                ObjectSerializer::toPathValue($customEventSchemaId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Management-Token');
        if ($apiKey !== null) {
            $headers['X-Management-Token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Management-Id');
        if ($apiKey !== null) {
            $headers['X-Management-Id'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getMetadataSchema1
     *
     * Get Metadata Schema
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $metadataSchemaId Provide the unique identifier of the metadata schema. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMetadataSchema1'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ManagementProjectsMetadataSchemasGetResponseBody
     */
    public function getMetadataSchema1($projectId, $metadataSchemaId, string $contentType = self::contentTypes['getMetadataSchema1'][0])
    {
        list($response) = $this->getMetadataSchema1WithHttpInfo($projectId, $metadataSchemaId, $contentType);
        return $response;
    }

    /**
     * Operation getMetadataSchema1WithHttpInfo
     *
     * Get Metadata Schema
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $metadataSchemaId Provide the unique identifier of the metadata schema. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMetadataSchema1'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ManagementProjectsMetadataSchemasGetResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function getMetadataSchema1WithHttpInfo($projectId, $metadataSchemaId, string $contentType = self::contentTypes['getMetadataSchema1'][0])
    {
        $request = $this->getMetadataSchema1Request($projectId, $metadataSchemaId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ManagementProjectsMetadataSchemasGetResponseBody' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ManagementProjectsMetadataSchemasGetResponseBody' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ManagementProjectsMetadataSchemasGetResponseBody', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ManagementProjectsMetadataSchemasGetResponseBody';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ManagementProjectsMetadataSchemasGetResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getMetadataSchema1Async
     *
     * Get Metadata Schema
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $metadataSchemaId Provide the unique identifier of the metadata schema. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMetadataSchema1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMetadataSchema1Async($projectId, $metadataSchemaId, string $contentType = self::contentTypes['getMetadataSchema1'][0])
    {
        return $this->getMetadataSchema1AsyncWithHttpInfo($projectId, $metadataSchemaId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getMetadataSchema1AsyncWithHttpInfo
     *
     * Get Metadata Schema
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $metadataSchemaId Provide the unique identifier of the metadata schema. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMetadataSchema1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMetadataSchema1AsyncWithHttpInfo($projectId, $metadataSchemaId, string $contentType = self::contentTypes['getMetadataSchema1'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ManagementProjectsMetadataSchemasGetResponseBody';
        $request = $this->getMetadataSchema1Request($projectId, $metadataSchemaId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getMetadataSchema1'
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $metadataSchemaId Provide the unique identifier of the metadata schema. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMetadataSchema1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getMetadataSchema1Request($projectId, $metadataSchemaId, string $contentType = self::contentTypes['getMetadataSchema1'][0])
    {

        // verify the required parameter 'projectId' is set
        if ($projectId === null || (is_array($projectId) && count($projectId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projectId when calling getMetadataSchema1'
            );
        }

        // verify the required parameter 'metadataSchemaId' is set
        if ($metadataSchemaId === null || (is_array($metadataSchemaId) && count($metadataSchemaId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $metadataSchemaId when calling getMetadataSchema1'
            );
        }


        $resourcePath = '/management/v1/projects/{projectId}/metadata-schemas/{metadataSchemaId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($projectId !== null) {
            $resourcePath = str_replace(
                '{' . 'projectId' . '}',
                ObjectSerializer::toPathValue($projectId),
                $resourcePath
            );
        }
        // path params
        if ($metadataSchemaId !== null) {
            $resourcePath = str_replace(
                '{' . 'metadataSchemaId' . '}',
                ObjectSerializer::toPathValue($metadataSchemaId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Management-Token');
        if ($apiKey !== null) {
            $headers['X-Management-Token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Management-Id');
        if ($apiKey !== null) {
            $headers['X-Management-Id'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getProject
     *
     * Get Project
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getProject'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ManagementProjectsGetResponseBody
     */
    public function getProject($projectId, string $contentType = self::contentTypes['getProject'][0])
    {
        list($response) = $this->getProjectWithHttpInfo($projectId, $contentType);
        return $response;
    }

    /**
     * Operation getProjectWithHttpInfo
     *
     * Get Project
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getProject'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ManagementProjectsGetResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function getProjectWithHttpInfo($projectId, string $contentType = self::contentTypes['getProject'][0])
    {
        $request = $this->getProjectRequest($projectId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ManagementProjectsGetResponseBody' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ManagementProjectsGetResponseBody' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ManagementProjectsGetResponseBody', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ManagementProjectsGetResponseBody';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ManagementProjectsGetResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getProjectAsync
     *
     * Get Project
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getProject'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getProjectAsync($projectId, string $contentType = self::contentTypes['getProject'][0])
    {
        return $this->getProjectAsyncWithHttpInfo($projectId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getProjectAsyncWithHttpInfo
     *
     * Get Project
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getProject'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getProjectAsyncWithHttpInfo($projectId, string $contentType = self::contentTypes['getProject'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ManagementProjectsGetResponseBody';
        $request = $this->getProjectRequest($projectId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getProject'
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getProject'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getProjectRequest($projectId, string $contentType = self::contentTypes['getProject'][0])
    {

        // verify the required parameter 'projectId' is set
        if ($projectId === null || (is_array($projectId) && count($projectId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projectId when calling getProject'
            );
        }


        $resourcePath = '/management/v1/projects/{projectId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($projectId !== null) {
            $resourcePath = str_replace(
                '{' . 'projectId' . '}',
                ObjectSerializer::toPathValue($projectId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Management-Token');
        if ($apiKey !== null) {
            $headers['X-Management-Token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Management-Id');
        if ($apiKey !== null) {
            $headers['X-Management-Id'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getStackingRules
     *
     * Get Stacking Rules
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $stackingRulesId Provide the unique identifier of the stacking rules. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getStackingRules'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ManagementProjectsStackingRulesGetResponseBody
     */
    public function getStackingRules($projectId, $stackingRulesId, string $contentType = self::contentTypes['getStackingRules'][0])
    {
        list($response) = $this->getStackingRulesWithHttpInfo($projectId, $stackingRulesId, $contentType);
        return $response;
    }

    /**
     * Operation getStackingRulesWithHttpInfo
     *
     * Get Stacking Rules
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $stackingRulesId Provide the unique identifier of the stacking rules. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getStackingRules'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ManagementProjectsStackingRulesGetResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function getStackingRulesWithHttpInfo($projectId, $stackingRulesId, string $contentType = self::contentTypes['getStackingRules'][0])
    {
        $request = $this->getStackingRulesRequest($projectId, $stackingRulesId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ManagementProjectsStackingRulesGetResponseBody' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ManagementProjectsStackingRulesGetResponseBody' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ManagementProjectsStackingRulesGetResponseBody', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ManagementProjectsStackingRulesGetResponseBody';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ManagementProjectsStackingRulesGetResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getStackingRulesAsync
     *
     * Get Stacking Rules
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $stackingRulesId Provide the unique identifier of the stacking rules. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getStackingRules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStackingRulesAsync($projectId, $stackingRulesId, string $contentType = self::contentTypes['getStackingRules'][0])
    {
        return $this->getStackingRulesAsyncWithHttpInfo($projectId, $stackingRulesId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getStackingRulesAsyncWithHttpInfo
     *
     * Get Stacking Rules
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $stackingRulesId Provide the unique identifier of the stacking rules. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getStackingRules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStackingRulesAsyncWithHttpInfo($projectId, $stackingRulesId, string $contentType = self::contentTypes['getStackingRules'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ManagementProjectsStackingRulesGetResponseBody';
        $request = $this->getStackingRulesRequest($projectId, $stackingRulesId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getStackingRules'
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $stackingRulesId Provide the unique identifier of the stacking rules. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getStackingRules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getStackingRulesRequest($projectId, $stackingRulesId, string $contentType = self::contentTypes['getStackingRules'][0])
    {

        // verify the required parameter 'projectId' is set
        if ($projectId === null || (is_array($projectId) && count($projectId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projectId when calling getStackingRules'
            );
        }

        // verify the required parameter 'stackingRulesId' is set
        if ($stackingRulesId === null || (is_array($stackingRulesId) && count($stackingRulesId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $stackingRulesId when calling getStackingRules'
            );
        }


        $resourcePath = '/management/v1/projects/{projectId}/stacking-rules/{stackingRulesId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($projectId !== null) {
            $resourcePath = str_replace(
                '{' . 'projectId' . '}',
                ObjectSerializer::toPathValue($projectId),
                $resourcePath
            );
        }
        // path params
        if ($stackingRulesId !== null) {
            $resourcePath = str_replace(
                '{' . 'stackingRulesId' . '}',
                ObjectSerializer::toPathValue($stackingRulesId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Management-Token');
        if ($apiKey !== null) {
            $headers['X-Management-Token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Management-Id');
        if ($apiKey !== null) {
            $headers['X-Management-Id'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getUser
     *
     * Get User
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $userId Provide the unique identifier of the user. Alternatively, provide the users login. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUser'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ManagementProjectsUsersGetUserResponseBody
     */
    public function getUser($projectId, $userId, string $contentType = self::contentTypes['getUser'][0])
    {
        list($response) = $this->getUserWithHttpInfo($projectId, $userId, $contentType);
        return $response;
    }

    /**
     * Operation getUserWithHttpInfo
     *
     * Get User
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $userId Provide the unique identifier of the user. Alternatively, provide the users login. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUser'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ManagementProjectsUsersGetUserResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function getUserWithHttpInfo($projectId, $userId, string $contentType = self::contentTypes['getUser'][0])
    {
        $request = $this->getUserRequest($projectId, $userId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ManagementProjectsUsersGetUserResponseBody' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ManagementProjectsUsersGetUserResponseBody' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ManagementProjectsUsersGetUserResponseBody', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ManagementProjectsUsersGetUserResponseBody';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ManagementProjectsUsersGetUserResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getUserAsync
     *
     * Get User
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $userId Provide the unique identifier of the user. Alternatively, provide the users login. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUserAsync($projectId, $userId, string $contentType = self::contentTypes['getUser'][0])
    {
        return $this->getUserAsyncWithHttpInfo($projectId, $userId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getUserAsyncWithHttpInfo
     *
     * Get User
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $userId Provide the unique identifier of the user. Alternatively, provide the users login. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUserAsyncWithHttpInfo($projectId, $userId, string $contentType = self::contentTypes['getUser'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ManagementProjectsUsersGetUserResponseBody';
        $request = $this->getUserRequest($projectId, $userId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getUser'
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $userId Provide the unique identifier of the user. Alternatively, provide the users login. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getUserRequest($projectId, $userId, string $contentType = self::contentTypes['getUser'][0])
    {

        // verify the required parameter 'projectId' is set
        if ($projectId === null || (is_array($projectId) && count($projectId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projectId when calling getUser'
            );
        }

        // verify the required parameter 'userId' is set
        if ($userId === null || (is_array($userId) && count($userId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userId when calling getUser'
            );
        }


        $resourcePath = '/management/v1/projects/{projectId}/users/{userId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($projectId !== null) {
            $resourcePath = str_replace(
                '{' . 'projectId' . '}',
                ObjectSerializer::toPathValue($projectId),
                $resourcePath
            );
        }
        // path params
        if ($userId !== null) {
            $resourcePath = str_replace(
                '{' . 'userId' . '}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Management-Token');
        if ($apiKey !== null) {
            $headers['X-Management-Token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Management-Id');
        if ($apiKey !== null) {
            $headers['X-Management-Id'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getWebhook
     *
     * Get Webhook
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $webhookId Provide the unique identifier of the webhook configuration. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getWebhook'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ManagementProjectsWebhooksGetResponseBody
     */
    public function getWebhook($projectId, $webhookId, string $contentType = self::contentTypes['getWebhook'][0])
    {
        list($response) = $this->getWebhookWithHttpInfo($projectId, $webhookId, $contentType);
        return $response;
    }

    /**
     * Operation getWebhookWithHttpInfo
     *
     * Get Webhook
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $webhookId Provide the unique identifier of the webhook configuration. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getWebhook'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ManagementProjectsWebhooksGetResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function getWebhookWithHttpInfo($projectId, $webhookId, string $contentType = self::contentTypes['getWebhook'][0])
    {
        $request = $this->getWebhookRequest($projectId, $webhookId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ManagementProjectsWebhooksGetResponseBody' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ManagementProjectsWebhooksGetResponseBody' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ManagementProjectsWebhooksGetResponseBody', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ManagementProjectsWebhooksGetResponseBody';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ManagementProjectsWebhooksGetResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getWebhookAsync
     *
     * Get Webhook
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $webhookId Provide the unique identifier of the webhook configuration. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getWebhook'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWebhookAsync($projectId, $webhookId, string $contentType = self::contentTypes['getWebhook'][0])
    {
        return $this->getWebhookAsyncWithHttpInfo($projectId, $webhookId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getWebhookAsyncWithHttpInfo
     *
     * Get Webhook
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $webhookId Provide the unique identifier of the webhook configuration. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getWebhook'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWebhookAsyncWithHttpInfo($projectId, $webhookId, string $contentType = self::contentTypes['getWebhook'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ManagementProjectsWebhooksGetResponseBody';
        $request = $this->getWebhookRequest($projectId, $webhookId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getWebhook'
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $webhookId Provide the unique identifier of the webhook configuration. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getWebhook'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getWebhookRequest($projectId, $webhookId, string $contentType = self::contentTypes['getWebhook'][0])
    {

        // verify the required parameter 'projectId' is set
        if ($projectId === null || (is_array($projectId) && count($projectId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projectId when calling getWebhook'
            );
        }

        // verify the required parameter 'webhookId' is set
        if ($webhookId === null || (is_array($webhookId) && count($webhookId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webhookId when calling getWebhook'
            );
        }


        $resourcePath = '/management/v1/projects/{projectId}/webhooks/{webhookId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($projectId !== null) {
            $resourcePath = str_replace(
                '{' . 'projectId' . '}',
                ObjectSerializer::toPathValue($projectId),
                $resourcePath
            );
        }
        // path params
        if ($webhookId !== null) {
            $resourcePath = str_replace(
                '{' . 'webhookId' . '}',
                ObjectSerializer::toPathValue($webhookId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Management-Token');
        if ($apiKey !== null) {
            $headers['X-Management-Token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Management-Id');
        if ($apiKey !== null) {
            $headers['X-Management-Id'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inviteUser
     *
     * Invite a New User
     *
     * @param  \OpenAPI\Client\Model\ManagementProjectsUsersInviteCreateRequestBody $managementProjectsUsersInviteCreateRequestBody Defines the details of the invitation, the project, and roles to which the user will be assigned. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['inviteUser'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function inviteUser($managementProjectsUsersInviteCreateRequestBody = null, string $contentType = self::contentTypes['inviteUser'][0])
    {
        $this->inviteUserWithHttpInfo($managementProjectsUsersInviteCreateRequestBody, $contentType);
    }

    /**
     * Operation inviteUserWithHttpInfo
     *
     * Invite a New User
     *
     * @param  \OpenAPI\Client\Model\ManagementProjectsUsersInviteCreateRequestBody $managementProjectsUsersInviteCreateRequestBody Defines the details of the invitation, the project, and roles to which the user will be assigned. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['inviteUser'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function inviteUserWithHttpInfo($managementProjectsUsersInviteCreateRequestBody = null, string $contentType = self::contentTypes['inviteUser'][0])
    {
        $request = $this->inviteUserRequest($managementProjectsUsersInviteCreateRequestBody, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation inviteUserAsync
     *
     * Invite a New User
     *
     * @param  \OpenAPI\Client\Model\ManagementProjectsUsersInviteCreateRequestBody $managementProjectsUsersInviteCreateRequestBody Defines the details of the invitation, the project, and roles to which the user will be assigned. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['inviteUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inviteUserAsync($managementProjectsUsersInviteCreateRequestBody = null, string $contentType = self::contentTypes['inviteUser'][0])
    {
        return $this->inviteUserAsyncWithHttpInfo($managementProjectsUsersInviteCreateRequestBody, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inviteUserAsyncWithHttpInfo
     *
     * Invite a New User
     *
     * @param  \OpenAPI\Client\Model\ManagementProjectsUsersInviteCreateRequestBody $managementProjectsUsersInviteCreateRequestBody Defines the details of the invitation, the project, and roles to which the user will be assigned. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['inviteUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inviteUserAsyncWithHttpInfo($managementProjectsUsersInviteCreateRequestBody = null, string $contentType = self::contentTypes['inviteUser'][0])
    {
        $returnType = '';
        $request = $this->inviteUserRequest($managementProjectsUsersInviteCreateRequestBody, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inviteUser'
     *
     * @param  \OpenAPI\Client\Model\ManagementProjectsUsersInviteCreateRequestBody $managementProjectsUsersInviteCreateRequestBody Defines the details of the invitation, the project, and roles to which the user will be assigned. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['inviteUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function inviteUserRequest($managementProjectsUsersInviteCreateRequestBody = null, string $contentType = self::contentTypes['inviteUser'][0])
    {



        $resourcePath = '/management/v1/projects/users/invite';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($managementProjectsUsersInviteCreateRequestBody)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($managementProjectsUsersInviteCreateRequestBody));
            } else {
                $httpBody = $managementProjectsUsersInviteCreateRequestBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Management-Token');
        if ($apiKey !== null) {
            $headers['X-Management-Token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Management-Id');
        if ($apiKey !== null) {
            $headers['X-Management-Id'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listBrands
     *
     * List Brands
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listBrands'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ManagementProjectsBrandingListResponseBody
     */
    public function listBrands($projectId, string $contentType = self::contentTypes['listBrands'][0])
    {
        list($response) = $this->listBrandsWithHttpInfo($projectId, $contentType);
        return $response;
    }

    /**
     * Operation listBrandsWithHttpInfo
     *
     * List Brands
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listBrands'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ManagementProjectsBrandingListResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function listBrandsWithHttpInfo($projectId, string $contentType = self::contentTypes['listBrands'][0])
    {
        $request = $this->listBrandsRequest($projectId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ManagementProjectsBrandingListResponseBody' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ManagementProjectsBrandingListResponseBody' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ManagementProjectsBrandingListResponseBody', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ManagementProjectsBrandingListResponseBody';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ManagementProjectsBrandingListResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listBrandsAsync
     *
     * List Brands
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listBrands'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listBrandsAsync($projectId, string $contentType = self::contentTypes['listBrands'][0])
    {
        return $this->listBrandsAsyncWithHttpInfo($projectId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listBrandsAsyncWithHttpInfo
     *
     * List Brands
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listBrands'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listBrandsAsyncWithHttpInfo($projectId, string $contentType = self::contentTypes['listBrands'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ManagementProjectsBrandingListResponseBody';
        $request = $this->listBrandsRequest($projectId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listBrands'
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listBrands'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listBrandsRequest($projectId, string $contentType = self::contentTypes['listBrands'][0])
    {

        // verify the required parameter 'projectId' is set
        if ($projectId === null || (is_array($projectId) && count($projectId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projectId when calling listBrands'
            );
        }


        $resourcePath = '/management/v1/projects/{projectId}/branding';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($projectId !== null) {
            $resourcePath = str_replace(
                '{' . 'projectId' . '}',
                ObjectSerializer::toPathValue($projectId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Management-Token');
        if ($apiKey !== null) {
            $headers['X-Management-Token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Management-Id');
        if ($apiKey !== null) {
            $headers['X-Management-Id'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listCustomEventSchemas
     *
     * List Custom Event Schemas
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCustomEventSchemas'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ManagementProjectsCustomEventSchemasListResponseBody
     */
    public function listCustomEventSchemas($projectId, string $contentType = self::contentTypes['listCustomEventSchemas'][0])
    {
        list($response) = $this->listCustomEventSchemasWithHttpInfo($projectId, $contentType);
        return $response;
    }

    /**
     * Operation listCustomEventSchemasWithHttpInfo
     *
     * List Custom Event Schemas
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCustomEventSchemas'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ManagementProjectsCustomEventSchemasListResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function listCustomEventSchemasWithHttpInfo($projectId, string $contentType = self::contentTypes['listCustomEventSchemas'][0])
    {
        $request = $this->listCustomEventSchemasRequest($projectId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ManagementProjectsCustomEventSchemasListResponseBody' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ManagementProjectsCustomEventSchemasListResponseBody' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ManagementProjectsCustomEventSchemasListResponseBody', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ManagementProjectsCustomEventSchemasListResponseBody';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ManagementProjectsCustomEventSchemasListResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listCustomEventSchemasAsync
     *
     * List Custom Event Schemas
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCustomEventSchemas'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCustomEventSchemasAsync($projectId, string $contentType = self::contentTypes['listCustomEventSchemas'][0])
    {
        return $this->listCustomEventSchemasAsyncWithHttpInfo($projectId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listCustomEventSchemasAsyncWithHttpInfo
     *
     * List Custom Event Schemas
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCustomEventSchemas'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCustomEventSchemasAsyncWithHttpInfo($projectId, string $contentType = self::contentTypes['listCustomEventSchemas'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ManagementProjectsCustomEventSchemasListResponseBody';
        $request = $this->listCustomEventSchemasRequest($projectId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listCustomEventSchemas'
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCustomEventSchemas'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listCustomEventSchemasRequest($projectId, string $contentType = self::contentTypes['listCustomEventSchemas'][0])
    {

        // verify the required parameter 'projectId' is set
        if ($projectId === null || (is_array($projectId) && count($projectId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projectId when calling listCustomEventSchemas'
            );
        }


        $resourcePath = '/management/v1/projects/{projectId}/custom-event-schemas';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($projectId !== null) {
            $resourcePath = str_replace(
                '{' . 'projectId' . '}',
                ObjectSerializer::toPathValue($projectId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Management-Token');
        if ($apiKey !== null) {
            $headers['X-Management-Token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Management-Id');
        if ($apiKey !== null) {
            $headers['X-Management-Id'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listMetadataSchemas1
     *
     * List Metadata Schemas
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMetadataSchemas1'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ManagementProjectsMetadataSchemasListResponseBody
     */
    public function listMetadataSchemas1($projectId, string $contentType = self::contentTypes['listMetadataSchemas1'][0])
    {
        list($response) = $this->listMetadataSchemas1WithHttpInfo($projectId, $contentType);
        return $response;
    }

    /**
     * Operation listMetadataSchemas1WithHttpInfo
     *
     * List Metadata Schemas
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMetadataSchemas1'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ManagementProjectsMetadataSchemasListResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function listMetadataSchemas1WithHttpInfo($projectId, string $contentType = self::contentTypes['listMetadataSchemas1'][0])
    {
        $request = $this->listMetadataSchemas1Request($projectId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ManagementProjectsMetadataSchemasListResponseBody' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ManagementProjectsMetadataSchemasListResponseBody' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ManagementProjectsMetadataSchemasListResponseBody', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ManagementProjectsMetadataSchemasListResponseBody';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ManagementProjectsMetadataSchemasListResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listMetadataSchemas1Async
     *
     * List Metadata Schemas
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMetadataSchemas1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listMetadataSchemas1Async($projectId, string $contentType = self::contentTypes['listMetadataSchemas1'][0])
    {
        return $this->listMetadataSchemas1AsyncWithHttpInfo($projectId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listMetadataSchemas1AsyncWithHttpInfo
     *
     * List Metadata Schemas
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMetadataSchemas1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listMetadataSchemas1AsyncWithHttpInfo($projectId, string $contentType = self::contentTypes['listMetadataSchemas1'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ManagementProjectsMetadataSchemasListResponseBody';
        $request = $this->listMetadataSchemas1Request($projectId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listMetadataSchemas1'
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMetadataSchemas1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listMetadataSchemas1Request($projectId, string $contentType = self::contentTypes['listMetadataSchemas1'][0])
    {

        // verify the required parameter 'projectId' is set
        if ($projectId === null || (is_array($projectId) && count($projectId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projectId when calling listMetadataSchemas1'
            );
        }


        $resourcePath = '/management/v1/projects/{projectId}/metadata-schemas';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($projectId !== null) {
            $resourcePath = str_replace(
                '{' . 'projectId' . '}',
                ObjectSerializer::toPathValue($projectId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Management-Token');
        if ($apiKey !== null) {
            $headers['X-Management-Token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Management-Id');
        if ($apiKey !== null) {
            $headers['X-Management-Id'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listProjects
     *
     * List Projects
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listProjects'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ManagementProjectsListResponseBody
     */
    public function listProjects(string $contentType = self::contentTypes['listProjects'][0])
    {
        list($response) = $this->listProjectsWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation listProjectsWithHttpInfo
     *
     * List Projects
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listProjects'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ManagementProjectsListResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function listProjectsWithHttpInfo(string $contentType = self::contentTypes['listProjects'][0])
    {
        $request = $this->listProjectsRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ManagementProjectsListResponseBody' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ManagementProjectsListResponseBody' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ManagementProjectsListResponseBody', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ManagementProjectsListResponseBody';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ManagementProjectsListResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listProjectsAsync
     *
     * List Projects
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listProjects'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listProjectsAsync(string $contentType = self::contentTypes['listProjects'][0])
    {
        return $this->listProjectsAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listProjectsAsyncWithHttpInfo
     *
     * List Projects
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listProjects'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listProjectsAsyncWithHttpInfo(string $contentType = self::contentTypes['listProjects'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ManagementProjectsListResponseBody';
        $request = $this->listProjectsRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listProjects'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listProjects'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listProjectsRequest(string $contentType = self::contentTypes['listProjects'][0])
    {


        $resourcePath = '/management/v1/projects';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Management-Token');
        if ($apiKey !== null) {
            $headers['X-Management-Token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Management-Id');
        if ($apiKey !== null) {
            $headers['X-Management-Id'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listStackingRules
     *
     * List Stacking Rules
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listStackingRules'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ManagementProjectsStackingRulesListResponseBody
     */
    public function listStackingRules($projectId, string $contentType = self::contentTypes['listStackingRules'][0])
    {
        list($response) = $this->listStackingRulesWithHttpInfo($projectId, $contentType);
        return $response;
    }

    /**
     * Operation listStackingRulesWithHttpInfo
     *
     * List Stacking Rules
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listStackingRules'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ManagementProjectsStackingRulesListResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function listStackingRulesWithHttpInfo($projectId, string $contentType = self::contentTypes['listStackingRules'][0])
    {
        $request = $this->listStackingRulesRequest($projectId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ManagementProjectsStackingRulesListResponseBody' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ManagementProjectsStackingRulesListResponseBody' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ManagementProjectsStackingRulesListResponseBody', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ManagementProjectsStackingRulesListResponseBody';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ManagementProjectsStackingRulesListResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listStackingRulesAsync
     *
     * List Stacking Rules
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listStackingRules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listStackingRulesAsync($projectId, string $contentType = self::contentTypes['listStackingRules'][0])
    {
        return $this->listStackingRulesAsyncWithHttpInfo($projectId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listStackingRulesAsyncWithHttpInfo
     *
     * List Stacking Rules
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listStackingRules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listStackingRulesAsyncWithHttpInfo($projectId, string $contentType = self::contentTypes['listStackingRules'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ManagementProjectsStackingRulesListResponseBody';
        $request = $this->listStackingRulesRequest($projectId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listStackingRules'
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listStackingRules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listStackingRulesRequest($projectId, string $contentType = self::contentTypes['listStackingRules'][0])
    {

        // verify the required parameter 'projectId' is set
        if ($projectId === null || (is_array($projectId) && count($projectId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projectId when calling listStackingRules'
            );
        }


        $resourcePath = '/management/v1/projects/{projectId}/stacking-rules';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($projectId !== null) {
            $resourcePath = str_replace(
                '{' . 'projectId' . '}',
                ObjectSerializer::toPathValue($projectId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Management-Token');
        if ($apiKey !== null) {
            $headers['X-Management-Token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Management-Id');
        if ($apiKey !== null) {
            $headers['X-Management-Id'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listUsers
     *
     * List Users
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listUsers'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ManagementProjectsUsersListResponseBody
     */
    public function listUsers($projectId, string $contentType = self::contentTypes['listUsers'][0])
    {
        list($response) = $this->listUsersWithHttpInfo($projectId, $contentType);
        return $response;
    }

    /**
     * Operation listUsersWithHttpInfo
     *
     * List Users
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listUsers'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ManagementProjectsUsersListResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function listUsersWithHttpInfo($projectId, string $contentType = self::contentTypes['listUsers'][0])
    {
        $request = $this->listUsersRequest($projectId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ManagementProjectsUsersListResponseBody' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ManagementProjectsUsersListResponseBody' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ManagementProjectsUsersListResponseBody', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ManagementProjectsUsersListResponseBody';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ManagementProjectsUsersListResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listUsersAsync
     *
     * List Users
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listUsers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listUsersAsync($projectId, string $contentType = self::contentTypes['listUsers'][0])
    {
        return $this->listUsersAsyncWithHttpInfo($projectId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listUsersAsyncWithHttpInfo
     *
     * List Users
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listUsers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listUsersAsyncWithHttpInfo($projectId, string $contentType = self::contentTypes['listUsers'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ManagementProjectsUsersListResponseBody';
        $request = $this->listUsersRequest($projectId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listUsers'
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listUsers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listUsersRequest($projectId, string $contentType = self::contentTypes['listUsers'][0])
    {

        // verify the required parameter 'projectId' is set
        if ($projectId === null || (is_array($projectId) && count($projectId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projectId when calling listUsers'
            );
        }


        $resourcePath = '/management/v1/projects/{projectId}/users';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($projectId !== null) {
            $resourcePath = str_replace(
                '{' . 'projectId' . '}',
                ObjectSerializer::toPathValue($projectId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Management-Token');
        if ($apiKey !== null) {
            $headers['X-Management-Token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Management-Id');
        if ($apiKey !== null) {
            $headers['X-Management-Id'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listWebhooks
     *
     * List Webhooks
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listWebhooks'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ManagementProjectsWebhooksListResponseBody
     */
    public function listWebhooks($projectId, string $contentType = self::contentTypes['listWebhooks'][0])
    {
        list($response) = $this->listWebhooksWithHttpInfo($projectId, $contentType);
        return $response;
    }

    /**
     * Operation listWebhooksWithHttpInfo
     *
     * List Webhooks
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listWebhooks'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ManagementProjectsWebhooksListResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function listWebhooksWithHttpInfo($projectId, string $contentType = self::contentTypes['listWebhooks'][0])
    {
        $request = $this->listWebhooksRequest($projectId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ManagementProjectsWebhooksListResponseBody' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ManagementProjectsWebhooksListResponseBody' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ManagementProjectsWebhooksListResponseBody', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ManagementProjectsWebhooksListResponseBody';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ManagementProjectsWebhooksListResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listWebhooksAsync
     *
     * List Webhooks
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listWebhooks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listWebhooksAsync($projectId, string $contentType = self::contentTypes['listWebhooks'][0])
    {
        return $this->listWebhooksAsyncWithHttpInfo($projectId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listWebhooksAsyncWithHttpInfo
     *
     * List Webhooks
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listWebhooks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listWebhooksAsyncWithHttpInfo($projectId, string $contentType = self::contentTypes['listWebhooks'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ManagementProjectsWebhooksListResponseBody';
        $request = $this->listWebhooksRequest($projectId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listWebhooks'
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listWebhooks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listWebhooksRequest($projectId, string $contentType = self::contentTypes['listWebhooks'][0])
    {

        // verify the required parameter 'projectId' is set
        if ($projectId === null || (is_array($projectId) && count($projectId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projectId when calling listWebhooks'
            );
        }


        $resourcePath = '/management/v1/projects/{projectId}/webhooks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($projectId !== null) {
            $resourcePath = str_replace(
                '{' . 'projectId' . '}',
                ObjectSerializer::toPathValue($projectId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Management-Token');
        if ($apiKey !== null) {
            $headers['X-Management-Token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Management-Id');
        if ($apiKey !== null) {
            $headers['X-Management-Id'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation unassignUser
     *
     * Unassign User
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $userId Provide the unique identifier of the user. Alternatively, provide the users login. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unassignUser'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function unassignUser($projectId, $userId, string $contentType = self::contentTypes['unassignUser'][0])
    {
        $this->unassignUserWithHttpInfo($projectId, $userId, $contentType);
    }

    /**
     * Operation unassignUserWithHttpInfo
     *
     * Unassign User
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $userId Provide the unique identifier of the user. Alternatively, provide the users login. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unassignUser'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function unassignUserWithHttpInfo($projectId, $userId, string $contentType = self::contentTypes['unassignUser'][0])
    {
        $request = $this->unassignUserRequest($projectId, $userId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation unassignUserAsync
     *
     * Unassign User
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $userId Provide the unique identifier of the user. Alternatively, provide the users login. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unassignUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function unassignUserAsync($projectId, $userId, string $contentType = self::contentTypes['unassignUser'][0])
    {
        return $this->unassignUserAsyncWithHttpInfo($projectId, $userId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation unassignUserAsyncWithHttpInfo
     *
     * Unassign User
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $userId Provide the unique identifier of the user. Alternatively, provide the users login. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unassignUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function unassignUserAsyncWithHttpInfo($projectId, $userId, string $contentType = self::contentTypes['unassignUser'][0])
    {
        $returnType = '';
        $request = $this->unassignUserRequest($projectId, $userId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'unassignUser'
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $userId Provide the unique identifier of the user. Alternatively, provide the users login. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unassignUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function unassignUserRequest($projectId, $userId, string $contentType = self::contentTypes['unassignUser'][0])
    {

        // verify the required parameter 'projectId' is set
        if ($projectId === null || (is_array($projectId) && count($projectId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projectId when calling unassignUser'
            );
        }

        // verify the required parameter 'userId' is set
        if ($userId === null || (is_array($userId) && count($userId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userId when calling unassignUser'
            );
        }


        $resourcePath = '/management/v1/projects/{projectId}/users/{userId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($projectId !== null) {
            $resourcePath = str_replace(
                '{' . 'projectId' . '}',
                ObjectSerializer::toPathValue($projectId),
                $resourcePath
            );
        }
        // path params
        if ($userId !== null) {
            $resourcePath = str_replace(
                '{' . 'userId' . '}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Management-Token');
        if ($apiKey !== null) {
            $headers['X-Management-Token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Management-Id');
        if ($apiKey !== null) {
            $headers['X-Management-Id'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateBrand
     *
     * Update Brand
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $brandingId Provide the unique identifier of the brand configuration. (required)
     * @param  \OpenAPI\Client\Model\ManagementProjectsBrandingUpdateRequestBody $managementProjectsBrandingUpdateRequestBody Defines the brand configuration to be updated. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateBrand'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ManagementProjectsBrandingUpdateResponseBody
     */
    public function updateBrand($projectId, $brandingId, $managementProjectsBrandingUpdateRequestBody = null, string $contentType = self::contentTypes['updateBrand'][0])
    {
        list($response) = $this->updateBrandWithHttpInfo($projectId, $brandingId, $managementProjectsBrandingUpdateRequestBody, $contentType);
        return $response;
    }

    /**
     * Operation updateBrandWithHttpInfo
     *
     * Update Brand
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $brandingId Provide the unique identifier of the brand configuration. (required)
     * @param  \OpenAPI\Client\Model\ManagementProjectsBrandingUpdateRequestBody $managementProjectsBrandingUpdateRequestBody Defines the brand configuration to be updated. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateBrand'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ManagementProjectsBrandingUpdateResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateBrandWithHttpInfo($projectId, $brandingId, $managementProjectsBrandingUpdateRequestBody = null, string $contentType = self::contentTypes['updateBrand'][0])
    {
        $request = $this->updateBrandRequest($projectId, $brandingId, $managementProjectsBrandingUpdateRequestBody, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ManagementProjectsBrandingUpdateResponseBody' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ManagementProjectsBrandingUpdateResponseBody' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ManagementProjectsBrandingUpdateResponseBody', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ManagementProjectsBrandingUpdateResponseBody';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ManagementProjectsBrandingUpdateResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateBrandAsync
     *
     * Update Brand
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $brandingId Provide the unique identifier of the brand configuration. (required)
     * @param  \OpenAPI\Client\Model\ManagementProjectsBrandingUpdateRequestBody $managementProjectsBrandingUpdateRequestBody Defines the brand configuration to be updated. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateBrand'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateBrandAsync($projectId, $brandingId, $managementProjectsBrandingUpdateRequestBody = null, string $contentType = self::contentTypes['updateBrand'][0])
    {
        return $this->updateBrandAsyncWithHttpInfo($projectId, $brandingId, $managementProjectsBrandingUpdateRequestBody, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateBrandAsyncWithHttpInfo
     *
     * Update Brand
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $brandingId Provide the unique identifier of the brand configuration. (required)
     * @param  \OpenAPI\Client\Model\ManagementProjectsBrandingUpdateRequestBody $managementProjectsBrandingUpdateRequestBody Defines the brand configuration to be updated. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateBrand'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateBrandAsyncWithHttpInfo($projectId, $brandingId, $managementProjectsBrandingUpdateRequestBody = null, string $contentType = self::contentTypes['updateBrand'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ManagementProjectsBrandingUpdateResponseBody';
        $request = $this->updateBrandRequest($projectId, $brandingId, $managementProjectsBrandingUpdateRequestBody, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateBrand'
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $brandingId Provide the unique identifier of the brand configuration. (required)
     * @param  \OpenAPI\Client\Model\ManagementProjectsBrandingUpdateRequestBody $managementProjectsBrandingUpdateRequestBody Defines the brand configuration to be updated. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateBrand'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateBrandRequest($projectId, $brandingId, $managementProjectsBrandingUpdateRequestBody = null, string $contentType = self::contentTypes['updateBrand'][0])
    {

        // verify the required parameter 'projectId' is set
        if ($projectId === null || (is_array($projectId) && count($projectId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projectId when calling updateBrand'
            );
        }

        // verify the required parameter 'brandingId' is set
        if ($brandingId === null || (is_array($brandingId) && count($brandingId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $brandingId when calling updateBrand'
            );
        }



        $resourcePath = '/management/v1/projects/{projectId}/branding/{brandingId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($projectId !== null) {
            $resourcePath = str_replace(
                '{' . 'projectId' . '}',
                ObjectSerializer::toPathValue($projectId),
                $resourcePath
            );
        }
        // path params
        if ($brandingId !== null) {
            $resourcePath = str_replace(
                '{' . 'brandingId' . '}',
                ObjectSerializer::toPathValue($brandingId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($managementProjectsBrandingUpdateRequestBody)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($managementProjectsBrandingUpdateRequestBody));
            } else {
                $httpBody = $managementProjectsBrandingUpdateRequestBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Management-Token');
        if ($apiKey !== null) {
            $headers['X-Management-Token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Management-Id');
        if ($apiKey !== null) {
            $headers['X-Management-Id'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateCustomEventSchema
     *
     * Update Custom Event Schema
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $customEventSchemaId Provide the unique identifier of the custom event schema. (required)
     * @param  \OpenAPI\Client\Model\ManagementProjectsCustomEventSchemasUpdateRequestBody $managementProjectsCustomEventSchemasUpdateRequestBody Defines the custom event schema to be updated. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateCustomEventSchema'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ManagementProjectsCustomEventSchemasUpdateResponseBody
     */
    public function updateCustomEventSchema($projectId, $customEventSchemaId, $managementProjectsCustomEventSchemasUpdateRequestBody = null, string $contentType = self::contentTypes['updateCustomEventSchema'][0])
    {
        list($response) = $this->updateCustomEventSchemaWithHttpInfo($projectId, $customEventSchemaId, $managementProjectsCustomEventSchemasUpdateRequestBody, $contentType);
        return $response;
    }

    /**
     * Operation updateCustomEventSchemaWithHttpInfo
     *
     * Update Custom Event Schema
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $customEventSchemaId Provide the unique identifier of the custom event schema. (required)
     * @param  \OpenAPI\Client\Model\ManagementProjectsCustomEventSchemasUpdateRequestBody $managementProjectsCustomEventSchemasUpdateRequestBody Defines the custom event schema to be updated. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateCustomEventSchema'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ManagementProjectsCustomEventSchemasUpdateResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateCustomEventSchemaWithHttpInfo($projectId, $customEventSchemaId, $managementProjectsCustomEventSchemasUpdateRequestBody = null, string $contentType = self::contentTypes['updateCustomEventSchema'][0])
    {
        $request = $this->updateCustomEventSchemaRequest($projectId, $customEventSchemaId, $managementProjectsCustomEventSchemasUpdateRequestBody, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ManagementProjectsCustomEventSchemasUpdateResponseBody' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ManagementProjectsCustomEventSchemasUpdateResponseBody' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ManagementProjectsCustomEventSchemasUpdateResponseBody', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ManagementProjectsCustomEventSchemasUpdateResponseBody';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ManagementProjectsCustomEventSchemasUpdateResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateCustomEventSchemaAsync
     *
     * Update Custom Event Schema
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $customEventSchemaId Provide the unique identifier of the custom event schema. (required)
     * @param  \OpenAPI\Client\Model\ManagementProjectsCustomEventSchemasUpdateRequestBody $managementProjectsCustomEventSchemasUpdateRequestBody Defines the custom event schema to be updated. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateCustomEventSchema'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateCustomEventSchemaAsync($projectId, $customEventSchemaId, $managementProjectsCustomEventSchemasUpdateRequestBody = null, string $contentType = self::contentTypes['updateCustomEventSchema'][0])
    {
        return $this->updateCustomEventSchemaAsyncWithHttpInfo($projectId, $customEventSchemaId, $managementProjectsCustomEventSchemasUpdateRequestBody, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateCustomEventSchemaAsyncWithHttpInfo
     *
     * Update Custom Event Schema
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $customEventSchemaId Provide the unique identifier of the custom event schema. (required)
     * @param  \OpenAPI\Client\Model\ManagementProjectsCustomEventSchemasUpdateRequestBody $managementProjectsCustomEventSchemasUpdateRequestBody Defines the custom event schema to be updated. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateCustomEventSchema'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateCustomEventSchemaAsyncWithHttpInfo($projectId, $customEventSchemaId, $managementProjectsCustomEventSchemasUpdateRequestBody = null, string $contentType = self::contentTypes['updateCustomEventSchema'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ManagementProjectsCustomEventSchemasUpdateResponseBody';
        $request = $this->updateCustomEventSchemaRequest($projectId, $customEventSchemaId, $managementProjectsCustomEventSchemasUpdateRequestBody, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateCustomEventSchema'
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $customEventSchemaId Provide the unique identifier of the custom event schema. (required)
     * @param  \OpenAPI\Client\Model\ManagementProjectsCustomEventSchemasUpdateRequestBody $managementProjectsCustomEventSchemasUpdateRequestBody Defines the custom event schema to be updated. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateCustomEventSchema'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateCustomEventSchemaRequest($projectId, $customEventSchemaId, $managementProjectsCustomEventSchemasUpdateRequestBody = null, string $contentType = self::contentTypes['updateCustomEventSchema'][0])
    {

        // verify the required parameter 'projectId' is set
        if ($projectId === null || (is_array($projectId) && count($projectId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projectId when calling updateCustomEventSchema'
            );
        }

        // verify the required parameter 'customEventSchemaId' is set
        if ($customEventSchemaId === null || (is_array($customEventSchemaId) && count($customEventSchemaId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $customEventSchemaId when calling updateCustomEventSchema'
            );
        }



        $resourcePath = '/management/v1/projects/{projectId}/custom-event-schemas/{customEventSchemaId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($projectId !== null) {
            $resourcePath = str_replace(
                '{' . 'projectId' . '}',
                ObjectSerializer::toPathValue($projectId),
                $resourcePath
            );
        }
        // path params
        if ($customEventSchemaId !== null) {
            $resourcePath = str_replace(
                '{' . 'customEventSchemaId' . '}',
                ObjectSerializer::toPathValue($customEventSchemaId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($managementProjectsCustomEventSchemasUpdateRequestBody)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($managementProjectsCustomEventSchemasUpdateRequestBody));
            } else {
                $httpBody = $managementProjectsCustomEventSchemasUpdateRequestBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Management-Token');
        if ($apiKey !== null) {
            $headers['X-Management-Token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Management-Id');
        if ($apiKey !== null) {
            $headers['X-Management-Id'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateMetadataSchema
     *
     * Update Metadata Schema
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $metadataSchemaId Provide the unique identifier of the metadata schema. (required)
     * @param  \OpenAPI\Client\Model\ManagementProjectsMetadataSchemasUpdateRequestBody $managementProjectsMetadataSchemasUpdateRequestBody Defines the metadata schema to be updated. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateMetadataSchema'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ManagementProjectsMetadataSchemasUpdateResponseBody
     */
    public function updateMetadataSchema($projectId, $metadataSchemaId, $managementProjectsMetadataSchemasUpdateRequestBody = null, string $contentType = self::contentTypes['updateMetadataSchema'][0])
    {
        list($response) = $this->updateMetadataSchemaWithHttpInfo($projectId, $metadataSchemaId, $managementProjectsMetadataSchemasUpdateRequestBody, $contentType);
        return $response;
    }

    /**
     * Operation updateMetadataSchemaWithHttpInfo
     *
     * Update Metadata Schema
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $metadataSchemaId Provide the unique identifier of the metadata schema. (required)
     * @param  \OpenAPI\Client\Model\ManagementProjectsMetadataSchemasUpdateRequestBody $managementProjectsMetadataSchemasUpdateRequestBody Defines the metadata schema to be updated. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateMetadataSchema'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ManagementProjectsMetadataSchemasUpdateResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateMetadataSchemaWithHttpInfo($projectId, $metadataSchemaId, $managementProjectsMetadataSchemasUpdateRequestBody = null, string $contentType = self::contentTypes['updateMetadataSchema'][0])
    {
        $request = $this->updateMetadataSchemaRequest($projectId, $metadataSchemaId, $managementProjectsMetadataSchemasUpdateRequestBody, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ManagementProjectsMetadataSchemasUpdateResponseBody' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ManagementProjectsMetadataSchemasUpdateResponseBody' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ManagementProjectsMetadataSchemasUpdateResponseBody', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ManagementProjectsMetadataSchemasUpdateResponseBody';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ManagementProjectsMetadataSchemasUpdateResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateMetadataSchemaAsync
     *
     * Update Metadata Schema
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $metadataSchemaId Provide the unique identifier of the metadata schema. (required)
     * @param  \OpenAPI\Client\Model\ManagementProjectsMetadataSchemasUpdateRequestBody $managementProjectsMetadataSchemasUpdateRequestBody Defines the metadata schema to be updated. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateMetadataSchema'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateMetadataSchemaAsync($projectId, $metadataSchemaId, $managementProjectsMetadataSchemasUpdateRequestBody = null, string $contentType = self::contentTypes['updateMetadataSchema'][0])
    {
        return $this->updateMetadataSchemaAsyncWithHttpInfo($projectId, $metadataSchemaId, $managementProjectsMetadataSchemasUpdateRequestBody, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateMetadataSchemaAsyncWithHttpInfo
     *
     * Update Metadata Schema
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $metadataSchemaId Provide the unique identifier of the metadata schema. (required)
     * @param  \OpenAPI\Client\Model\ManagementProjectsMetadataSchemasUpdateRequestBody $managementProjectsMetadataSchemasUpdateRequestBody Defines the metadata schema to be updated. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateMetadataSchema'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateMetadataSchemaAsyncWithHttpInfo($projectId, $metadataSchemaId, $managementProjectsMetadataSchemasUpdateRequestBody = null, string $contentType = self::contentTypes['updateMetadataSchema'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ManagementProjectsMetadataSchemasUpdateResponseBody';
        $request = $this->updateMetadataSchemaRequest($projectId, $metadataSchemaId, $managementProjectsMetadataSchemasUpdateRequestBody, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateMetadataSchema'
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $metadataSchemaId Provide the unique identifier of the metadata schema. (required)
     * @param  \OpenAPI\Client\Model\ManagementProjectsMetadataSchemasUpdateRequestBody $managementProjectsMetadataSchemasUpdateRequestBody Defines the metadata schema to be updated. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateMetadataSchema'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateMetadataSchemaRequest($projectId, $metadataSchemaId, $managementProjectsMetadataSchemasUpdateRequestBody = null, string $contentType = self::contentTypes['updateMetadataSchema'][0])
    {

        // verify the required parameter 'projectId' is set
        if ($projectId === null || (is_array($projectId) && count($projectId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projectId when calling updateMetadataSchema'
            );
        }

        // verify the required parameter 'metadataSchemaId' is set
        if ($metadataSchemaId === null || (is_array($metadataSchemaId) && count($metadataSchemaId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $metadataSchemaId when calling updateMetadataSchema'
            );
        }



        $resourcePath = '/management/v1/projects/{projectId}/metadata-schemas/{metadataSchemaId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($projectId !== null) {
            $resourcePath = str_replace(
                '{' . 'projectId' . '}',
                ObjectSerializer::toPathValue($projectId),
                $resourcePath
            );
        }
        // path params
        if ($metadataSchemaId !== null) {
            $resourcePath = str_replace(
                '{' . 'metadataSchemaId' . '}',
                ObjectSerializer::toPathValue($metadataSchemaId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($managementProjectsMetadataSchemasUpdateRequestBody)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($managementProjectsMetadataSchemasUpdateRequestBody));
            } else {
                $httpBody = $managementProjectsMetadataSchemasUpdateRequestBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Management-Token');
        if ($apiKey !== null) {
            $headers['X-Management-Token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Management-Id');
        if ($apiKey !== null) {
            $headers['X-Management-Id'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateProject
     *
     * Update Project
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  \OpenAPI\Client\Model\ManagementProjectsUpdateRequestBody $managementProjectsUpdateRequestBody Define the project details to be updated. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateProject'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ManagementProjectsUpdateResponseBody
     */
    public function updateProject($projectId, $managementProjectsUpdateRequestBody = null, string $contentType = self::contentTypes['updateProject'][0])
    {
        list($response) = $this->updateProjectWithHttpInfo($projectId, $managementProjectsUpdateRequestBody, $contentType);
        return $response;
    }

    /**
     * Operation updateProjectWithHttpInfo
     *
     * Update Project
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  \OpenAPI\Client\Model\ManagementProjectsUpdateRequestBody $managementProjectsUpdateRequestBody Define the project details to be updated. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateProject'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ManagementProjectsUpdateResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateProjectWithHttpInfo($projectId, $managementProjectsUpdateRequestBody = null, string $contentType = self::contentTypes['updateProject'][0])
    {
        $request = $this->updateProjectRequest($projectId, $managementProjectsUpdateRequestBody, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ManagementProjectsUpdateResponseBody' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ManagementProjectsUpdateResponseBody' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ManagementProjectsUpdateResponseBody', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ManagementProjectsUpdateResponseBody';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ManagementProjectsUpdateResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateProjectAsync
     *
     * Update Project
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  \OpenAPI\Client\Model\ManagementProjectsUpdateRequestBody $managementProjectsUpdateRequestBody Define the project details to be updated. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateProject'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateProjectAsync($projectId, $managementProjectsUpdateRequestBody = null, string $contentType = self::contentTypes['updateProject'][0])
    {
        return $this->updateProjectAsyncWithHttpInfo($projectId, $managementProjectsUpdateRequestBody, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateProjectAsyncWithHttpInfo
     *
     * Update Project
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  \OpenAPI\Client\Model\ManagementProjectsUpdateRequestBody $managementProjectsUpdateRequestBody Define the project details to be updated. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateProject'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateProjectAsyncWithHttpInfo($projectId, $managementProjectsUpdateRequestBody = null, string $contentType = self::contentTypes['updateProject'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ManagementProjectsUpdateResponseBody';
        $request = $this->updateProjectRequest($projectId, $managementProjectsUpdateRequestBody, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateProject'
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  \OpenAPI\Client\Model\ManagementProjectsUpdateRequestBody $managementProjectsUpdateRequestBody Define the project details to be updated. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateProject'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateProjectRequest($projectId, $managementProjectsUpdateRequestBody = null, string $contentType = self::contentTypes['updateProject'][0])
    {

        // verify the required parameter 'projectId' is set
        if ($projectId === null || (is_array($projectId) && count($projectId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projectId when calling updateProject'
            );
        }



        $resourcePath = '/management/v1/projects/{projectId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($projectId !== null) {
            $resourcePath = str_replace(
                '{' . 'projectId' . '}',
                ObjectSerializer::toPathValue($projectId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($managementProjectsUpdateRequestBody)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($managementProjectsUpdateRequestBody));
            } else {
                $httpBody = $managementProjectsUpdateRequestBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Management-Token');
        if ($apiKey !== null) {
            $headers['X-Management-Token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Management-Id');
        if ($apiKey !== null) {
            $headers['X-Management-Id'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateStackingRules
     *
     * Update Stacking Rules
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $stackingRulesId Provide the unique identifier of the stacking rules. (required)
     * @param  \OpenAPI\Client\Model\ManagementProjectsStackingRulesUpdateRequestBody $managementProjectsStackingRulesUpdateRequestBody Defines the stacking rules to be updated. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateStackingRules'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ManagementProjectsStackingRulesUpdateResponseBody
     */
    public function updateStackingRules($projectId, $stackingRulesId, $managementProjectsStackingRulesUpdateRequestBody = null, string $contentType = self::contentTypes['updateStackingRules'][0])
    {
        list($response) = $this->updateStackingRulesWithHttpInfo($projectId, $stackingRulesId, $managementProjectsStackingRulesUpdateRequestBody, $contentType);
        return $response;
    }

    /**
     * Operation updateStackingRulesWithHttpInfo
     *
     * Update Stacking Rules
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $stackingRulesId Provide the unique identifier of the stacking rules. (required)
     * @param  \OpenAPI\Client\Model\ManagementProjectsStackingRulesUpdateRequestBody $managementProjectsStackingRulesUpdateRequestBody Defines the stacking rules to be updated. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateStackingRules'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ManagementProjectsStackingRulesUpdateResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateStackingRulesWithHttpInfo($projectId, $stackingRulesId, $managementProjectsStackingRulesUpdateRequestBody = null, string $contentType = self::contentTypes['updateStackingRules'][0])
    {
        $request = $this->updateStackingRulesRequest($projectId, $stackingRulesId, $managementProjectsStackingRulesUpdateRequestBody, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ManagementProjectsStackingRulesUpdateResponseBody' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ManagementProjectsStackingRulesUpdateResponseBody' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ManagementProjectsStackingRulesUpdateResponseBody', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ManagementProjectsStackingRulesUpdateResponseBody';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ManagementProjectsStackingRulesUpdateResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateStackingRulesAsync
     *
     * Update Stacking Rules
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $stackingRulesId Provide the unique identifier of the stacking rules. (required)
     * @param  \OpenAPI\Client\Model\ManagementProjectsStackingRulesUpdateRequestBody $managementProjectsStackingRulesUpdateRequestBody Defines the stacking rules to be updated. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateStackingRules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateStackingRulesAsync($projectId, $stackingRulesId, $managementProjectsStackingRulesUpdateRequestBody = null, string $contentType = self::contentTypes['updateStackingRules'][0])
    {
        return $this->updateStackingRulesAsyncWithHttpInfo($projectId, $stackingRulesId, $managementProjectsStackingRulesUpdateRequestBody, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateStackingRulesAsyncWithHttpInfo
     *
     * Update Stacking Rules
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $stackingRulesId Provide the unique identifier of the stacking rules. (required)
     * @param  \OpenAPI\Client\Model\ManagementProjectsStackingRulesUpdateRequestBody $managementProjectsStackingRulesUpdateRequestBody Defines the stacking rules to be updated. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateStackingRules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateStackingRulesAsyncWithHttpInfo($projectId, $stackingRulesId, $managementProjectsStackingRulesUpdateRequestBody = null, string $contentType = self::contentTypes['updateStackingRules'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ManagementProjectsStackingRulesUpdateResponseBody';
        $request = $this->updateStackingRulesRequest($projectId, $stackingRulesId, $managementProjectsStackingRulesUpdateRequestBody, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateStackingRules'
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $stackingRulesId Provide the unique identifier of the stacking rules. (required)
     * @param  \OpenAPI\Client\Model\ManagementProjectsStackingRulesUpdateRequestBody $managementProjectsStackingRulesUpdateRequestBody Defines the stacking rules to be updated. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateStackingRules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateStackingRulesRequest($projectId, $stackingRulesId, $managementProjectsStackingRulesUpdateRequestBody = null, string $contentType = self::contentTypes['updateStackingRules'][0])
    {

        // verify the required parameter 'projectId' is set
        if ($projectId === null || (is_array($projectId) && count($projectId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projectId when calling updateStackingRules'
            );
        }

        // verify the required parameter 'stackingRulesId' is set
        if ($stackingRulesId === null || (is_array($stackingRulesId) && count($stackingRulesId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $stackingRulesId when calling updateStackingRules'
            );
        }



        $resourcePath = '/management/v1/projects/{projectId}/stacking-rules/{stackingRulesId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($projectId !== null) {
            $resourcePath = str_replace(
                '{' . 'projectId' . '}',
                ObjectSerializer::toPathValue($projectId),
                $resourcePath
            );
        }
        // path params
        if ($stackingRulesId !== null) {
            $resourcePath = str_replace(
                '{' . 'stackingRulesId' . '}',
                ObjectSerializer::toPathValue($stackingRulesId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($managementProjectsStackingRulesUpdateRequestBody)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($managementProjectsStackingRulesUpdateRequestBody));
            } else {
                $httpBody = $managementProjectsStackingRulesUpdateRequestBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Management-Token');
        if ($apiKey !== null) {
            $headers['X-Management-Token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Management-Id');
        if ($apiKey !== null) {
            $headers['X-Management-Id'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateUser
     *
     * Update User
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $userId Provide the unique identifier of the user. Alternatively, provide the users login. (required)
     * @param  \OpenAPI\Client\Model\ManagementProjectsUsersUpdateRoleRequestBody $managementProjectsUsersUpdateRoleRequestBody Defines the users new role. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateUser'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ManagementProjectsUsersUpdateRoleResponseBody
     */
    public function updateUser($projectId, $userId, $managementProjectsUsersUpdateRoleRequestBody = null, string $contentType = self::contentTypes['updateUser'][0])
    {
        list($response) = $this->updateUserWithHttpInfo($projectId, $userId, $managementProjectsUsersUpdateRoleRequestBody, $contentType);
        return $response;
    }

    /**
     * Operation updateUserWithHttpInfo
     *
     * Update User
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $userId Provide the unique identifier of the user. Alternatively, provide the users login. (required)
     * @param  \OpenAPI\Client\Model\ManagementProjectsUsersUpdateRoleRequestBody $managementProjectsUsersUpdateRoleRequestBody Defines the users new role. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateUser'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ManagementProjectsUsersUpdateRoleResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateUserWithHttpInfo($projectId, $userId, $managementProjectsUsersUpdateRoleRequestBody = null, string $contentType = self::contentTypes['updateUser'][0])
    {
        $request = $this->updateUserRequest($projectId, $userId, $managementProjectsUsersUpdateRoleRequestBody, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ManagementProjectsUsersUpdateRoleResponseBody' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ManagementProjectsUsersUpdateRoleResponseBody' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ManagementProjectsUsersUpdateRoleResponseBody', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ManagementProjectsUsersUpdateRoleResponseBody';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ManagementProjectsUsersUpdateRoleResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateUserAsync
     *
     * Update User
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $userId Provide the unique identifier of the user. Alternatively, provide the users login. (required)
     * @param  \OpenAPI\Client\Model\ManagementProjectsUsersUpdateRoleRequestBody $managementProjectsUsersUpdateRoleRequestBody Defines the users new role. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateUserAsync($projectId, $userId, $managementProjectsUsersUpdateRoleRequestBody = null, string $contentType = self::contentTypes['updateUser'][0])
    {
        return $this->updateUserAsyncWithHttpInfo($projectId, $userId, $managementProjectsUsersUpdateRoleRequestBody, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateUserAsyncWithHttpInfo
     *
     * Update User
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $userId Provide the unique identifier of the user. Alternatively, provide the users login. (required)
     * @param  \OpenAPI\Client\Model\ManagementProjectsUsersUpdateRoleRequestBody $managementProjectsUsersUpdateRoleRequestBody Defines the users new role. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateUserAsyncWithHttpInfo($projectId, $userId, $managementProjectsUsersUpdateRoleRequestBody = null, string $contentType = self::contentTypes['updateUser'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ManagementProjectsUsersUpdateRoleResponseBody';
        $request = $this->updateUserRequest($projectId, $userId, $managementProjectsUsersUpdateRoleRequestBody, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateUser'
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $userId Provide the unique identifier of the user. Alternatively, provide the users login. (required)
     * @param  \OpenAPI\Client\Model\ManagementProjectsUsersUpdateRoleRequestBody $managementProjectsUsersUpdateRoleRequestBody Defines the users new role. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateUserRequest($projectId, $userId, $managementProjectsUsersUpdateRoleRequestBody = null, string $contentType = self::contentTypes['updateUser'][0])
    {

        // verify the required parameter 'projectId' is set
        if ($projectId === null || (is_array($projectId) && count($projectId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projectId when calling updateUser'
            );
        }

        // verify the required parameter 'userId' is set
        if ($userId === null || (is_array($userId) && count($userId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userId when calling updateUser'
            );
        }



        $resourcePath = '/management/v1/projects/{projectId}/users/{userId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($projectId !== null) {
            $resourcePath = str_replace(
                '{' . 'projectId' . '}',
                ObjectSerializer::toPathValue($projectId),
                $resourcePath
            );
        }
        // path params
        if ($userId !== null) {
            $resourcePath = str_replace(
                '{' . 'userId' . '}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($managementProjectsUsersUpdateRoleRequestBody)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($managementProjectsUsersUpdateRoleRequestBody));
            } else {
                $httpBody = $managementProjectsUsersUpdateRoleRequestBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Management-Token');
        if ($apiKey !== null) {
            $headers['X-Management-Token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Management-Id');
        if ($apiKey !== null) {
            $headers['X-Management-Id'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateWebhook
     *
     * Update Webhook
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $webhookId Provide the unique identifier of the webhook configuration. (required)
     * @param  \OpenAPI\Client\Model\ManagementProjectsWebhooksUpdateRequestBody $managementProjectsWebhooksUpdateRequestBody Defines the webhook configuration to be updated. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateWebhook'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ManagementProjectsWebhooksUpdateResponseBody
     */
    public function updateWebhook($projectId, $webhookId, $managementProjectsWebhooksUpdateRequestBody = null, string $contentType = self::contentTypes['updateWebhook'][0])
    {
        list($response) = $this->updateWebhookWithHttpInfo($projectId, $webhookId, $managementProjectsWebhooksUpdateRequestBody, $contentType);
        return $response;
    }

    /**
     * Operation updateWebhookWithHttpInfo
     *
     * Update Webhook
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $webhookId Provide the unique identifier of the webhook configuration. (required)
     * @param  \OpenAPI\Client\Model\ManagementProjectsWebhooksUpdateRequestBody $managementProjectsWebhooksUpdateRequestBody Defines the webhook configuration to be updated. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateWebhook'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ManagementProjectsWebhooksUpdateResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateWebhookWithHttpInfo($projectId, $webhookId, $managementProjectsWebhooksUpdateRequestBody = null, string $contentType = self::contentTypes['updateWebhook'][0])
    {
        $request = $this->updateWebhookRequest($projectId, $webhookId, $managementProjectsWebhooksUpdateRequestBody, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ManagementProjectsWebhooksUpdateResponseBody' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ManagementProjectsWebhooksUpdateResponseBody' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ManagementProjectsWebhooksUpdateResponseBody', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ManagementProjectsWebhooksUpdateResponseBody';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ManagementProjectsWebhooksUpdateResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateWebhookAsync
     *
     * Update Webhook
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $webhookId Provide the unique identifier of the webhook configuration. (required)
     * @param  \OpenAPI\Client\Model\ManagementProjectsWebhooksUpdateRequestBody $managementProjectsWebhooksUpdateRequestBody Defines the webhook configuration to be updated. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateWebhook'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateWebhookAsync($projectId, $webhookId, $managementProjectsWebhooksUpdateRequestBody = null, string $contentType = self::contentTypes['updateWebhook'][0])
    {
        return $this->updateWebhookAsyncWithHttpInfo($projectId, $webhookId, $managementProjectsWebhooksUpdateRequestBody, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateWebhookAsyncWithHttpInfo
     *
     * Update Webhook
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $webhookId Provide the unique identifier of the webhook configuration. (required)
     * @param  \OpenAPI\Client\Model\ManagementProjectsWebhooksUpdateRequestBody $managementProjectsWebhooksUpdateRequestBody Defines the webhook configuration to be updated. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateWebhook'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateWebhookAsyncWithHttpInfo($projectId, $webhookId, $managementProjectsWebhooksUpdateRequestBody = null, string $contentType = self::contentTypes['updateWebhook'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ManagementProjectsWebhooksUpdateResponseBody';
        $request = $this->updateWebhookRequest($projectId, $webhookId, $managementProjectsWebhooksUpdateRequestBody, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateWebhook'
     *
     * @param  string $projectId Provide the unique identifier of the project. (required)
     * @param  string $webhookId Provide the unique identifier of the webhook configuration. (required)
     * @param  \OpenAPI\Client\Model\ManagementProjectsWebhooksUpdateRequestBody $managementProjectsWebhooksUpdateRequestBody Defines the webhook configuration to be updated. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateWebhook'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateWebhookRequest($projectId, $webhookId, $managementProjectsWebhooksUpdateRequestBody = null, string $contentType = self::contentTypes['updateWebhook'][0])
    {

        // verify the required parameter 'projectId' is set
        if ($projectId === null || (is_array($projectId) && count($projectId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projectId when calling updateWebhook'
            );
        }

        // verify the required parameter 'webhookId' is set
        if ($webhookId === null || (is_array($webhookId) && count($webhookId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webhookId when calling updateWebhook'
            );
        }



        $resourcePath = '/management/v1/projects/{projectId}/webhooks/{webhookId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($projectId !== null) {
            $resourcePath = str_replace(
                '{' . 'projectId' . '}',
                ObjectSerializer::toPathValue($projectId),
                $resourcePath
            );
        }
        // path params
        if ($webhookId !== null) {
            $resourcePath = str_replace(
                '{' . 'webhookId' . '}',
                ObjectSerializer::toPathValue($webhookId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($managementProjectsWebhooksUpdateRequestBody)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($managementProjectsWebhooksUpdateRequestBody));
            } else {
                $httpBody = $managementProjectsWebhooksUpdateRequestBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Management-Token');
        if ($apiKey !== null) {
            $headers['X-Management-Token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Management-Id');
        if ($apiKey !== null) {
            $headers['X-Management-Id'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
